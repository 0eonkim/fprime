**Outline (combines basic procedure and tool-based commands)**

5\. Recommended F′ Development Process

> i. Getting Started with F′
> 
> a. F´ Terminology
> 
> ii. F′ Utility
> 
> a. Setting Up a CMake Build
> 
> b. Build Cache Generation
> 
> c. Generate the Ref Application
> 
> d. Generate the F′ Framework
> 
> e. Generate a Raspberry PI Cross-Compile of the Ref Application
> 
> iii. Building Components and Deployments
> 
> a. Build SignalGen Component
> 
> b. Build Ref Deployment
> 
> iv. Installing the F′ Executable and Dictionaries
> 
> a. Installing the Ref Deployment and Running the Binary Assuming Linux
> 
> v. Creating Implementation Stubs
> 
> a. Generating Implementation Stubs of SignalGen
> 
> vi. Creating Unit Test Implementations
> 
> a. Generating Unit Test Stubs of SignalGen
> 
> vii. Building and Running Unit Tests
> 
> a. Building Unit Test of SignalGen
> 
> b. Cross-Compile Unit Test of SignalGen
> 
> viii. Conclusion

**5. Recommended F′ Development Process**

**i. Getting Started with F′**

**Prerequisite:** INSTALL.md

**Scope:** This tutorial provides the user with basic actions of the F′
development suite. The user must read through the INSTALL.md
installation guide, and have a working F′ installation prior to
continuing with this process.

**Goal:** This tutorial is designed to build familiarity with the F′
environment and tools. It does not provide instruction of new F′ items,
but rather uses the existing F′ Ref example as a place to operate the
tools, learn the environment, and learn F′.

The full development process is covered in the Math Component Tutorial,
which builds on the knowledge learned here.

**a. F´ Terminology**

This section covers basic terminology used in this and other tutorials
related to F′. It may be used as a reference for keywords that have
specific meaning in an F′ project.

**Port:** Represents a connection between components. These act as
communication channels in F′. This allows components to interact with
each other. A set of ports acts as a defined interface to a component.

**Component:** Location of program behavior. Components execute the
software logic of the system and typically define an interface of ports
that allow them to interact with other components. Components
additionally may define commands, events, channels, and parameters,
which define standard data patterns in F′.

**Topology:** Represents the full F′ system. It is a set of components
and the connections between those components. Topology specifies the
full system and all the communication channels.

**Event (also known as an EVR):** Type of downlinked data that
represents a single event in the system. It is composed of a name,
format string, and set of arguments that described what happened. Events
represent a history of the system, and are defined per-component.

**Channel (also known as a telemetry item):** Single value read and
downlinked. Channels consist of a type, a format specifier, and a value.
Channels represent current system state, and are defined per-component.

**Commands:** Uplinked data items that instruct the system to perform an
action. Commands consist of an opcode, a mnemonic, a list of arguments
to the command, and are defined per-component.

**Deployment:** Single instance of F′. Although a single F′ project can
use/define multiple deployments, a deployment represents one
build/executable.

**Build Directory/Build Cache:** Directory, created by the fprime-util
described section ii. b. It is required to build CMake projects. It
stores all by-products, generated code, and build products from an F′
build.

**Ground System:** Computer system that collects the data from the
activated F′ deployment. There is a basic ground system supplied with F′
for development purposes.

**Toolchain:** Set of tools to build a specific architecture, i.e., the
“raspberrypi” toolchain builds F′ deployments for the arm/Linux
architecture of the raspberry pi.

**ii. F′ Utility**

In order to ease in development, the F′ team has created a small wrapper
for the CMake build system. This recovers the advantages of the previous
development pattern, while allowing the power and configurability of
CMake as an underlying build architecture.

**a. Setting Up a CMake Build**

This is a quick reference for the development process used for the FSW
workshop. In order to build code, use CMake. This means builds are
typically done in a separate directory from the source.

mkdir build

cmake \<path/to/deployment\>

make \<target or empty\>

**Ports**

To add new ports into the system do the following steps.

**Note:** adding files listed below is easiest by copying from an
existing port and editing it.

1.  Create a new port directory

2.  Create a port \*Ai.xml file and fill it out

3.  Add CMakeLists.txt by ensuring the port's \*Ai.xml is listed in
    SOURCE\_FILES

4.  Add port directory to the Deployment's CMakeLists.txt

5.  (In CMake Build Directory) make \<port target name i.e.
    RobotArm\_I2cPort\>

**Components**

**Note:** adding files listed below is easiest by copying from an
existing component and editing it.

1.  Create a new component directory

2.  Create a component \*Ai.xml file and fill it out

3.  Run \<fprime\>/Autocoders/Python/bin/implgen.py -b \<Path to
    BUILD\_ROOT\> \<path to Ai.xml\>

4.  Rename the generated \*-template files to remove the -template
    suffix

5.  Add CMakeLists.txt by ensuring the component’s \*Ai.xml and
    \*Impl.cpp is listed in SOURCE\_FILES

6.  Add component directory to the deployment's CMakeLists.txt

7.  (In CMake Build Directory) make \<port target name i.e.
    RobotArm\_I2cPort\>

**Deployments**

1.  Create a Top topology directory. This contains Main.cpp and other
    files.

2.  Create a deployment CMakeLists.txt file, including all components
    and ports using add\_fprime\_subdirectory.

3.  (In CMake Build Directory) make

**b. Build Cache Generation**

Generate a working build cache using the F′ utility with the “generate”
command. This command takes a single argument of the F′ toolchain the
user selects to build. The default is read from the deployment
CMakeLists.txt and is typically “native.”

**c. Generate the Ref Application**

cd fprime/Ref

fprime-util generate

The utility creates two builds: one for the standard build, and one for
the unit test build. This enables the user to take advantage of all F′
parts without generating their own CMake build caches.

If the user chooses to edit or test individual F′ built-in components,
the user should also generate builds at the F′ library's root as shown
in section iii.

**d. Generate the F′ Framework**

cd fprime

fprime-util generate

The user can cross-compile using a different toolchain by using the
toolchain argument. The above invocations assume the default toolchain,
which if not configured, is “native.”

**e. Generate a Raspberry PI Cross-Compile of the Ref Application**

cd fprime/Ref

fprime-util generate raspberrypi

**iii. Building Components and Deployments**

In order to build a component or deployment with F′, the user may run
the “build” command as part of the fprime-utility to build the “current
directory.” This means that should the user change into a deployment
directory then the build command builds the full deployment. Should the
user desire to build a component, navigate to the directory and run the
build command.

**a. Build SignalGen Component**

cd fprime/Ref/SignalGen

fprime-util build

The user can also build a deployment by navigating to the deployment
directory and running the build command, as shown directly below.

**b. Build Ref Deployment**

cd fprime/Ref

fprime-util build

**Note:** the user typically should run the “install” command on
deployments, as described in section iv. This builds the binary like
“build,” but also copies the binary to the deployments “bin”
directory. i.e., fprime/Ref/bin.

This process also built the dictionaries for the project and places the
dictionary in the “top” folder of the deployment. This happens any time
the “install” or “build” command are run on a deployment.

The user can also build a component or deployment for a cross-compile by
specifying the toolchain. A previous generate for that toolchain should
have been run. Again for deployments, the user typically should run
“install,” as described in section iv.

cd fprime/Ref/SignalGen

fprime-util build raspberrypi

cd fprime/Ref

fprime-util build raspberrypi

**iv. Installing the F´ Executable and Dictionaries**

Once the deployment is built, install the binary and dictionaries. This
enables users to quickly find and run the deployment. This installation
is run using the following command, and everything is installed to the
directory defining the deployment, i.e., fprime/Ref/bin. Install invokes
“build” so users should use this in-place of build for deployments.

**a. Installing the Ref Deployment and Running the Binary Assuming
Linux**

cd fprime/Ref

fprime-util install

./bin/Linux/Ref \# Run the deployment

CTRL-C \# Exit the application

Running the application as part of the development ground data system is
shown below.

The user can also install a cross-compile.

cd fprime/Ref

fprime-util install raspberrypi

**v. Creating Implementation Stubs**

Once the build system is running, generate the stubbed implementations
of the component's C++ files using the “impl” command of the F′ utility.
These commands assume a default build has been generated. While they can
also be run passing in a toolchain, it is typically not done since they
are toolchain independent.

**a. Generating Implementation Stubs of SignalGen**

cd fprime/Ref/SignalGen

fprime-util impl

This creates two files for the component. These are
\<Component\>Impl.cpp-template and \<Component\>Impl.hpp-template. The
user can rename these files to remove -template. The file is ready for
C++ development.

**Note:** By generating -template files, this prevents accidentally
overwriting any existing implementation.

**vi. Creating Unit Test Implementations**

Once the build system is running, generate the stubbed implementations
and other files needed for building UTs for a component's C++ using the
“impl” command of the F´ utility. These commands assume a default
build has been generated. While they can also be run passing in a
toolchain, it is typically not done since they are toolchain
independent.

**a. Generating Unit Test Stubs of SignalGen**

cd fprime/Ref/SignalGen

fprime-util impl-ut

This creates the following files that are typically moved to a sub
folder called test/ut. The files created are placed in the current
directory and named:

Tester.cpp

Tester.hpp

GTestBase.cpp

GTestBase.hpp

TesterBase.cpp

TesterBase.hpp

TestMain.cpp

**vii. Building and Running Unit Tests**

Unit tests are built using the the build-ut command of the fprime-util.
This allows us to build the unit tests in preparation to run them. The
user can also just run “check” to build and run the unit tests.

**a. Building Unit Test of SignalGen**

cd fprime/Ref/SignalGen

fprime-util build-ut

Once built, the unit test can be run using the following command.

cd fprime/Ref/SignalGen

fprime-util check

The output of the unit test should be displayed in the console.

The user can also build the unit test, but must copy it to the hardware
to run it. This can be done with a cross- compile by running the
commands listed in the next section.

**b. Cross-Compile Unit Test of SignalGen**

cd fprime/Ref/SignalGen

fprime-util build-ut raspberrypi

**viii. Conclusion**

The user should now be familiar with F´ terminology and with the
fprime-util tool used to build and develop F´ applications. The next
step is to follow the full MathComponent tutorial to create new ports,
components, and topologies. This provides the user with the entire
development process, using the tool-based commands learned in this
tutorial.

**Next:** Math Component Tutorial **Also See:** GPS Component Tutorial
for a cross-compiling tutorial.
