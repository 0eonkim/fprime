**Preliminary Outline**

8\. F´ Source Tree F´ Out of the Box Items

> i. Ground Data System
> 
> ii. F´ Utility Build Helper and CMake System
> 
> iii. Autocoder and Template
> 
> iv. Svc “Component Library”
> 
> v. Operating System Abstraction Layer
> 
> vi. Linux Drivers

**Need “how to” examples to support content throughout  
**

**8. F´ Source Tree F´ Out of the Box Items**

**i. Ground Data System**

The F′ user experience is intended to be an out-of-box ready to use
ground data system (GDS) solution than can easily run on Linux, Mas OSX,
or Windows platforms without any mission specific tailoring. The GDS
provides an end-user graphical user interface (GUI) tool and an
integration test application programming interface (API) to enable
integration testing and quick-look telemetry monitoring.

Initially, the user defines the mission specific dictionaries such as
commands and telemetry, and then the dictionaries are automatically
generated from a topology model.

The GDS is the operation function where the end-user communicates with
the command and telemetry processing, storage, and visualization (the
GDS) via the radio frequency command and telemetry data channel (Figure
1).

![](./media/image1.emf)

**Figure 1.** The GDS functions as an operation.

The improved F′ GDS client GUI (Figure 2) looks identical to the legacy
GSE client GUI; however, it is built on WxPython for improved widget
functionality, and with added stripcharting and histograms. This new GDS
client GUI replaces the old GSE client GUI built on Python 3.

![](./media/image2.emf)

**Figure 2.** The new F′ GDS client GUI.

**ii. F′ Utility Build Helper and CMake System need to set a time to
chat with Michael Starch on the build-system**

**iii. Autocoder and Template**

Autocoder automatically adds ports for registering commands, receiving
commands and reporting an execution status. F′ defines an Extensible
Markup Language (XML) schema that users can use to specify a model of a
FSW application. The model describes the application at a high level in
terms of the components, ports, and topologies of the F′ architecture.
The F′ autocoder translates the model into the C++ classes, such as:

• A abstract class *CComponentBase*, derived from the appropriate
framework base class, is the base class for the C component
implementation that contains generated code for receiving commands and
for sending and receiving invocations on ports.

• A concrete class *CComponentImpl*, derived from *CComponentBase*, is a
skeleton for the user-defined implementation of C that contains
stubbed-out handlers for the input ports, which overrides a pure virtual
function defined in *CComponentBase*. The user adds member variables and
helper functions as necessary, and fill in handler implementations. The
framework and the auto-generated base class take care of the details of
invocation handling, making it easy to define new components. The user
writes the handlers, sending data on output ports by calling member
functions defined in *CComponentBase*.

Each of the input ports has a pure virtual handler in the base class
that is implemented in the implementation class. The handler
implementation for port 3 sends data out on port 4 (Figure 3).

![](./media/image3.emf)

**Figure 3.** *ComponentBase* and *ComponentImpl* classes for a sample
component with three input ports and one output port.

The F′ autocoders extend to translate the XML dictionaries to the format
used by the ground tools in the mission. Resulting XML files are fully
compatible with handwritten XML, and pass through the C++ and ground
dictionary autocoders in exactly the same way, as shown in Figure 4.

![](./media/image4.emf)

**Figure 4.** F Prime Modeling and Code Generation.

JPL has developed a tool called *fpp-legacy-xml* that translates F Prime
Prime (FPP) representation language files into the XML format that is
currently used by the F′ autocoders.

Support is being added for rule-based testing to the F′ unit test
framework. The support consists of: 1) an abstract C++ base class
*Rule,* and 2) extensions to the test autocoders for writing assertions
in user-defined subclasses of *Rule*.

Autocoder provides a template for the tester class. The user adds tests
as a public method and can write the tests from a generated template
known as *Tester*. The class contains tests as members and contains the
component under the test as a member.

**iv. Svc “Component Library”**

When components call into libraries, there are two ways to write unit
tests: i) link against the library in the test, and ii) link against a
mock or stub library. Either way depends on the circumstances.

Linking against the library in the test avoids writing the mock or stub,
and proves that the component code works with the actual library.

Linking against a mock or stub library makes it easier to induce
behaviors for testing, such as inject faults, and may be the only option
for some platforms.

**v. Operating System Abstraction Layer**

An operating system abstraction layer (OSAL) provides implementations of
an application programming interface (API) for real-time operating
systems (RTOS) and non-real-time operating systems.

OSALs include a directory structure and build automation, such as
makefiles, to make it easier to build a project for a specific operating
system or hardware platform.

The F′ framework includes C++ building blocks for object-oriented
programming known as classes that provide abstractions of common
operating systems features. These features include threads, mutual
exclusion locks, message queues, files, timers, and clocks.

The open-source framework provides implementations of the operating
systems layer for Linux and Mac OS. The Linux implementation works in
Windows with the Cygwin open source interface.

JPL developed an implementation for VxWorks, a RTOS where time and
performance are critical, with features such as multitasking kernel,
preemptive scheduling, interrupt response, memory protection, message
queues, memory protection, and multi-OS messaging.

To port F′ to a new operating system *S*, write implementations of these
classes for *S*.

**vi. Linux Drivers need SME input**

Linux drivers handle different types of devices they are managing. To
build a Linux driver follow the standard life-cycle approach: *program*
the driver source files, particularly the kernel interface; *integrate*
the driver into the kernel and include the kernel source calls to the
driver functions; *configure* and then *compile* the new kernel, and
then *test* the driver by writing a user program.

Need more content…
