**Outline (content from Architecture PDF Slides provided by SME)**

4\. Concepts of F′

> i. Core F′ Constructs
> 
> a. Ports
> 
> 1\. Port Characteristics
> 
> 2\. Input/Output Ports
> 
> 3\. Serialization Ports
> 
> i. Commands, Telemetry, Events, and Parameters
> 
> ii. Multi-node Hub Pattern
> 
> b. Components
> 
> i. Component Characteristics
> 
> ii. Component Hierarchy
> 
> iii. Component Type
> 
> c. Topologies
> 
> d. Conclusion

**4. Concepts of F′**

**i. Core F′ Constructs**

F´ is an embedded systems framework developed with the following goals.
This makes it particularly well suited for small missions that need
reliable components and infrastructure provided from the framework in
order to minimize development cost, schedule, or effort. These missions
include CubeSats, small-sats, and deployables but F´ can be used for any
embedded system regardless of the project size or field.

The goals of the F′ small scale component software framework for space
are:

  - capture the reusability of frameworks

  - ease of separating and reassembling the system’s components

  - isolated components for ease of testing

  - ability to adapt to new contexts

  - capability to be portable to new architectures and platforms

  - ease of use by customers

  - scalable and configurable facilities in the architecture

  - perform well in resource constrained context

The core F′ software framework allows projects to be decomposed into a
set of components that are interconnected by ports. The components are
assembled into a topology, which represents the behavior of the entire
system.

**a. Ports**

**1. Port Characteristics**

Ports encapsulate typed interfaces in the architecture. They are the
point of interconnection in the software framework. Ports have
directionality: they represent an input, or an output. This direction
pertains to invocation, not necessarily data flow i.e. synchronous
output ports can retrieve data. Ports support arguments in order to pass
data to the receiving end of the invocation. Synchronous ports may also
return data to the invoker. F´ data types and primitaves may be used as
arguments to the port. Pointers and references are allowed as arguments
for performance purposes, but care should be taken to ensure correct
memory management. Multiple output ports can be connected to a single
input port.

![](./media/image1.emf)

**Figure 1. Port connectivity.** For *another type of port*, the call is
made to method on attached port. For the *component*, the incoming port
calls provide callback. For the *serialized port*, the port serializes
the call and passes it to a data buffer.

Arguments supplied to the interface translate the data to a data buffer.
The serialized ports are built-in types supported by the framework where
users can write custom types. Ports can have return valves; however, use
is limited to only return data when the component has synchronous
interface, and there is no serializable connections since serialization
passes a data buffer without returning one. This is further discussed in
the serialization ports section below.

**2. Input/Output Ports**

Ports are defined as input ports if they are any one of the following
types: i) synchronous, ii) guarded, and iii) asynchronous. Synchronous
inputs return immediately, and may return data. Guarded ports are like
synchronous but are guarded by a component-wide lock to prevent multiple
calls into guarded port from executing at the same time. Asynchronous
ports queue up requests that are then drained by the component’s
internal task thread. These types are shown in Figure 2.

![](./media/image2.emf)

**Figure 2. Developer written implementation class.** For the
*synchronous port*, the calls directly invoke derived functions without
passing through the queue. For the *guarded port*, the calls directly
invoke derived functions, but only after locking a mutex shared by all
guarded ports in the component. For the *asynchronous port*, the calls
are placed in a queue and dispatched on a thread that empties the queue.

Passive components support synchronous and guarded ports and the
execution context that executes these port types is supplied by the
caller. There is no queue to support asynchronous ports. Queued
components support all three port types; however, the queued component
needs at least one synchronous or guarded port to unload the queue and
at least one asynchronous port for the queue to make sense. Since queued
components do not supply a thread to service the queue, the internal
queue must be serviced internally to one of the synchronous port callsd.
Active components support all three port types; however, the active
component needs at least one asynchronous port for the queue and thread
to be make since. The designer should be aware how the different calls
interact, for example during reentrant port calls. These component types
are discussed further in the section below entitled component types.

Output ports are invoked by calling generated base class functions from
the implementation class. The behavior is handled by the input port the
output port is connected to, thus there are no special restrictions to
us output ports.

**3. Serialization**

Serialization takes a specific set of typed values or function arguments
and converts them in an architecture-independent way translating them to
a data buffer. A port calls’ commands and arguments are serialized and
placed on message queues in the receiving component. In addition command
arguments and telemetry values are passed as serialized buffers so that
components that transfer the data can be independent of the definition
of the data.

Users can define arbitrary interface argument types and the frameworks
automatically serializes the data for port calls. They can also define
complex types in XML where a code generator generates classes that are
serializable for use internally, and usable with the F´ supplied ground
system.

Serialization ports are special ports that handle serialized buffers
without automatically unpacking them. These ports can be connected to
any type of port, as shown in Figure 3. For input ports, the calling
port detects a connection and serializes arguments. For the output
ports, serialized port calls interface on the typed port that
deserializes arguments. Serialization ports do not support ports with
return types. These ports allow serialized data to be passed around by
generic components that do not know the type contained. The Hub pattern
often uses serialized ports such that data can be routed across a
address-space gap in a generic fashion.

![](./media/image3.emf)

**Figure 3. Serialization ports.** Input ports input the serialized
buffer, while the output ports output the serialized buffer.

Serialization ports are useful for generic storage and communication
components that do not need to know the type of port. This allows design
and implementation of command and data handling (C\&DH) components that
provide reusability. Tested C\&DH components are developed to implement
typical non-mission-specific flight functions that are specified in the
XML. These include commands, events, telemetry, and parameters; and
should be designed so the small-scale projects can handle sufficient
implementations straight away. Facility interfaces are defined to
support existing component implementations for uplink/downlink packet
types that provide input/output of ground systems and C\&DH components,
and uplink/downlink ports that provide projects with specific
uplink/downlink hardware.

**i. Commands, Telemetry, Events, and Parameters**

The code generator provides a method of implementing commands,
telemetry, events (EVRs), and parameters. It parses arguments, types,
and generates code to convert arguments to serialized data and
serialized data to arguments. Calls implementation functions with
deserialized arguments (commands), or provides base class functions to
implement calls (telemetry, events, and parameters). The code generator
uses port types that are specified in XML. These ports are then used in
components that provide interfaces for transporting or storing data for
those services. Further description of commands, telemetry, events, and
parameters are discussed directly below, and the component types are
defined in the section entitled component types.

**Commands:** component command XML specifies opcode, mnemonic,
arguments, and synchronization attributes. Arguments can be any built-in
type or external XML complex type, which can be a single argument, and
defines enumerations. Synchronization attributes are sync, async, or
guarded (similar to the ports). Async specifies message priority.

Implementation class implements the function for each command; and the
autocoder automatically adds ports for registering and receiving
commands, and reporting an execution status.

![](./media/image4.emf)

**Figure 4. Example of command dispatcher.** The command dispatcher
receives the raw buffer containing the command and arguments. The
command opcode is extracted, and lookup is made using table maps to
capture the opcode to send to the port allowing multiple opcode entries
per component. The argument buffer is then passed to the component, and
the command dispatcher becomes a passive component.

![](./media/image5.emf)

**Figure 5. Example of command sequence.** The command sequencer loads
the file from the file system, and sends the command and waits for the
response for each command file. A failed response terminates the
sequence, while a passed response moves to the next command creating an
active component.

**Events:** component event XML specifies ID, name, severity, arguments,
and format specifier string. Arguments can be any built-in type or
external XML complex type, which can be a single argument, and defines
enumerations. Format specifier strings follow the C format specifier
syntax, and are used by ground software and optional on-board consoles
to display a message with argument values.

Code generated base class provides the function to call for each event
with typed arguments; and the code generator automatically adds ports
for retrieving time tag and sending events. There are two independent
ports for sending events: i) binary, and ii) console. The binary port
has serialized arguments for transports to ground software. The console
port has the capability for a text port to send a string of events using
the format specifier.

![](./media/image6.emf)

**Figure 6. Example of event log.** The component implementation calls
function to generate the event. The base class function (code-generated)
retrieves the time tag from the time source component
(project-specific). The component sends the event to the event log
component, then the event log component places the event on the message
queue. The thread of the component sends the downlink with the event,
and the event log becomes an active component.

**Telemetry:** component telemetry XML specifies channels that have ID,
name, data type, and format specifier strings. Data type is any built-in
type or external XML complex type and defines enumerations. Format
specifier strings are used by ground software and optional on-board
consoles to display a message with argument values.

Code generated base class provides a function to call for each channel
with typed arguments, known as implementation class; and the code
generator automatically adds ports for retrieving time tag and sending
channelized data.

![](./media/image7.emf)

**Figure 7. Example of telemetry database.** The telemetry database has
a double-buffered array of telemetry buffers. Implementation class calls
base class function with telemetry channel update. The base class
function retrieves the time tag from the time source component, and then
writes the updated value to the telemetry database component. The
telemetry database writes the value to the active buffer, as the run
port is called periodically by the rate group. This then swaps the
active buffer and the run call copies the updated values to the downlink
creating a passive component.

A rate group is a container of *run()* ports that calls ports in order.
The list of run ports does not know which destinations are in active
components; however, the rate group is an active component.

**Parameters:** are traditional means of storing non-volatile states.
The framework provides code generation to manage; however, the user must
write a specific storage component. Component XML specifies parameters
that have ID, name, data type, and optional default value. Data type can
be any built-in type or external XML complex type and defines
enumerations. Default values are assigned in the event the parameter
cannot be retrieved.

The code generator automatically adds ports for retrieving parameters.
During initialization, a public method in the class is called which
retrieves the parameters and stores copies locally. Calls can reoccur if
the parameter is updated. The code generated base class provides
function to call for each parameter to retrieve the stored copy; and an
implementation class can call whenever the parameter value is needed.

![](./media/image8.emf)

**Figure 8. Example of parameter manager.** The parameter manager loads
the file containing parameters from the file system during
initialization. The initialization subsequently calls *loadParameters()*
on all components with parameters (can be called after). The uplink
parameter updates the stored value of the parameter, and the component
then refreshes the parameters by implementing the command to reload. The
parameter manager saves the updated values to the file system via the
command.

**ii. Multi-node Hub Pattern**

A hub is a component with multiple serialization input and output ports.
Typed ports on calling components are connected to serialized ports, as
previously shown in Figure 3. A single point of connection to a remote
node is essential for a central point of configuration transport, as
shown in Figure 9.

![](./media/image9.emf)

**Figure 9. Hub pattern.** Each hub instance is responsible for
connecting to a remote node. Input port calls are repeated to
corresponding output ports on a remote hub. These hubs have been
demonstrated on Sockets, ARINC 653 Channels, High-speed hardware bus
between nodes, and UARTs between nodes in an embedded system.

**b. Components**

The F′ component architecture is a design pattern based on an
architectural concept combined with a software architectural framework
(Figure 10); and framework classes and tools that are provided for the
developer. The component architecture implies usage patterns, as well as
usage constraints. It focuses on the concept of components and ports
that use code generation to produce code to implement common framework
logic. The developer specifies the code in XML and writes implementation
classes to implement the interfaces.

![](./media/image10.emf)

**Figure 10. Example of F′ component architecture pattern.**

**i. Component Characteristics**

Components encapsulate behavior, and are not aware of other components.
They are localized to one compute context with specific interfaces using
typed ports that have no direct call to other components.

![](./media/image11.emf)

**Figure 11. Context for threads.** The component executes the commands
and then produces the telemetry.

**ii. Component Hierarchy**

The component type hierarchy consists of core framework classes,
generated classes that implement architecture features, and developer
written classes that implement interfaces and project-specific logic, as
shown in Figure 12.

**iii. Component Type**

The user specifies the type of component in XML. There are three types
of components: i) passive, ii) queued, and iii) active. Calls to the
output port are on a thread of implementation functions, which is
dependent on the port type as discussed in the section above entitled
port characteristics.

**Passive component:** has no thread; port interface calls are made
directly to user derived class methods.

**Queued component:** has no thread; a queue is instantiated and
asynchronous port calls are serialized and placed on queue. The
implementation class makes a call to the base class to dispatch calls to
implementation class methods for asynchronous ports. The call can be
made from any implementation class function, and the thread of the
execution is provided by the caller to asynchronous ports. They can be
made from any implementation class function and the thread of execution
is provided by the caller and sent to a synchronous port.

**Active component:** has a thread of execution, as well as queue. The
thread dispatches port calls from the queue as it executes based on the
thread scheduler.

![](./media/image12.emf)

**Figure 12. Example of component class hierarchy.** Calls to the output
port are on thread implementation functions. The thread making call is
dependent on the port type.

**c. Topologies**

Components are instantiated at run time and then connected through the
ports into a specific set of interconnected components known as
topology, as shown in Figure 13. There are no code dependencies between
the components, only dependencies on port interface types. Alternate
implementations can easily be swapped, for example simulation versions.

![](./media/image13.emf)

**Figure 13. Example of a component topology.**

**d. Conclusion**

The F′ software framework is released as open source and has been ported
to Linux, MacOS, Windows (WSL), VxWorks, ARINC 653, RTEMS, Bare Metal
(No OS), PPC, Leon3, x86, ARM (A15/A7), and MSP430. Mature sets of CD\&H
components are available following flight process, such as code
inspections, static analysis, and full-coverage unit testing.
