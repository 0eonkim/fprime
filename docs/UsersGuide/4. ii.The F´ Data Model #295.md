**Outline (content from Architecture PDF Slides provided by SME)**

4\. Concepts of F′

> ii. The F´ Data Model
> 
> a. Serializables
> 
> b. Commands
> 
> c. Events
> 
> d. Telemetry
> 
> e. Parameters
> 
> f. Standard F´ Components
> 
> 1\. Command Dispatcher
> 
> 2\. Command Sequencer
> 
> 3\. Active Logger
> 
> 4\. Telemetry Channelizer
> 
> 5\. Parameter Database
> 
> 6\. Hub Pattern

**4. Concepts of F′**

**ii. The F′ Data Model**

Commands, events, telemetry, parameters, and serializables are a core
part of F´. Reference components are provided to manage them if the user
chooses. The code generator provides a method of implementing commands,
events, telemetry, parameters, and serializables. It parses arguments
and types using port types that are specified in XML, and passes the
service data in serialized form. Code is generated to convert arguments
to serialized data and serialized data to arguments as needed. Users
write implementation functions with deserialized arguments (commands) or
call provided base class functions to implement telemetry, events, and
parameters. The typed ports are then used in components that provide
interfaces for transporting or storing data for those services. Further
explanation of commands, events, telemetry, parameters, and
serializables, and how they are specified for components is provided
below.

**a. Serializables**

Serialization takes a specific set of typed values or function arguments
and converts them in an architecture-independent way translating them to
a data buffer. Port calls, commands and their arguments are serialized
and placed on message queues in the components. The command arguments
and telemetry values are passed and encoded/decoded, and the components
that store and pass data do not require knowledge of underlying types.

Users can define arbitrary interface argument type classes that are
automatically serialized by the ports. They can also define complex
types in XML where the code generator generates classes that are
automatically serializable for use internally, as well as to and from
ground software.

Serialization ports are special optional ports that handle serialized
buffers, and can be connected to any type of port. Input ports input the
serialized buffer, while the output ports output the serialized buffer.

**b. Commands**

Commands are a data uplinked to the embedded system to command the
system. In F´, commands are defined and implemented in components. This
allows the user to command components directly in the system.

Component command XML specifies the opcode, mnemonic, arguments, and
synchronization attributes. Arguments can be any built-in type or
external XML complex type, which can be a single argument, and defines
enumerations. Synchronization attributes are sync, async, or guarded
(similar to the ports). Async can optionally specify message priority,
as well as behavior when the message queue is full.

Implementation classes implement the function for each command. The
autocoder automatically adds ports for registering and receiving
commands and reporting an execution status.

**c. Events**

Events (EVRs) are a form of downlinked data. They represent a log of the
running system. These can be used to trace the execution of activities
in the system. Events are defined per component and are typically used
to capture what the component is doing. Events can be sporadic; however,
should all be captured for downlink. Events are reported with various
levels, or severities:

  - DIAGNOSTIC: Detailed traces of routine activities, not typically
    downlinked.

  - ACTIVITY\_LO: Traces of steps of major routine activities.

  - ACTIVITY\_HI: Traces of major activities

  - COMMAND: Traces of command execution at the system level. Limited to
    dispatching commands and executing sequences.

  - WARNING\_LO: Anomalous, but non-critical off-nominal events.

  - WARNING\_HI: Anomalous and critical off-nominal events in the
    system.

  - FATAL: Events where the system is compromised to the point where
    drastic action like a reset or power off are required.

The mapping of events to severity levels are based on the judgement of
the system designer.

Component event XML specifies ID, name, severity, arguments, and a
format specifier string. Arguments can be any built-in type or external
XML complex type, which can be a single argument, and defines
enumerations. Format specifier strings follow the C format specifier
syntax, and are used by ground software and optional onboard consoles to
display a message with argument values.

The code generated base class provides a function to call for each event
with typed arguments and the code generator automatically adds ports for
retrieving time tag and sending events. There are two independent ports
for sending events: i) binary, and ii) text. The binary port has
serialized arguments for transport to ground software. The text port has
the capability to send a string representation of events using the
format specifier.

The component implementation calls function to generate the event. The
base class function (code-generated) retrieves the time tag from the
time source component (project-specific).

**d. Telemetry**

Channelized telemetry, also known as channels or EHAs, are a form of
downlinked data that represents the current state of the embedded
system. Channels allow users to monitor data representing the current
state of the system. Channels are broken-up per component and are
typically sampled at a set rate and dowlinked.

Component telemetry XML specifies channels that have an ID, name, data
type, and format specifier strings. Data type is any built-in type or
external XML complex type and defines enumerations. Format specifier
strings are used by ground software and optional onboard consoles to
display a message with argument values.

A code generated base class provides a function to call for each channel
with typed arguments, invoked by the implementation class. The code
generator automatically adds ports for retrieving time tags and sending
channelized data.

**e. Parameters**

Parameters are a means of storing non-volatile state. The framework
provides code generation to manage parameters. The user must write a
specific storage component. F’ provides a basic component to read and
write parameters to file storage.

The component XML specifies parameters that have an ID, name, data type,
and optional default value. The data type can be any built-in type or
external XML complex type and defines enumerations. Default values are
optionally assigned in the event the parameter cannot be retrieved.

The code generator automatically adds ports for retrieving and saving
parameters. During initialization, a public method in the component is
called, which retrieves the parameters and stores copies locally. The
code generator also creates commands to set and save the parameter
values. The set command sets the local value of the parameter, and the
save command will send the current value to the parameter storage
component for writing to non-volatile storage.

**f. Standard F´ Components**

Below we describe the stand F′ components: command dispatcher, command
sequencer, active logger, telemetry channelizer, parameter database, and
hub patterns in further detail.

**1. Command Dispatcher**

The command dispatcher receives the raw buffer containing the command
and arguments. The command opcode is extracted, and lookup is made using
table maps to capture the opcode to send to the port allowing multiple
opcode entries per component. The argument buffer is then passed to the
component.

![](./media/image1.emf)

**Figure 1. Example of command dispatcher.**

**2. Command Sequencer**

The command sequencer loads the file from the file system, and sends the
command and waits for the response for each command in the file. A
failed response terminates the sequence, while a passed response moves
to the next command.

![](./media/image2.emf)

**Figure 2. Example of command sequence.**

**3. Active Logger**

The component sends the event to the event log component, then the event
log component places the event on the message queue. The thread of the
component sends the event to the downlink.

![](./media/image3.emf)

**Figure 3. Illustration of the event log.**

**4. Telemetry Channelizer**

The telemetry database has a double-buffered array of telemetry buffers.
Implementation class calls base class function with telemetry channel
update. The base class function retrieves the time tag from the time
source component, and then writes the updated value to the telemetry
database component. The telemetry database writes the value to the
active buffer, as the run port is called periodically by the rate group.
This then swaps the active buffer and the run call copies the updated
values to the downlink creating a passive component.

![](./media/image4.emf)

**Figure 4. Illustration of the telemetry database.**

**5. Parameter Database**

The parameter manager loads the file containing parameters from the file
system during initialization. The initialization subsequently calls
*loadParameters()* on all components with parameters (may be called
after initialization). The uplink parameter updates the stored value of
the parameter, and the component then refreshes the parameters by
implementing the command to reload. The parameter manager saves the
updated values to the file system via the command.

![](./media/image5.emf)

**Figure 5. Illustration of the parameter manager.**

**6. Hub Pattern**

A hub is a component with multiple serialization input and output ports.
Typed ports on calling components are connected to serialized ports. The
hub implementation can then send and receive the serialized data on
whatever transport layer is required, as shown in Figure 6.

![](./media/image6.emf)

**Figure 6. Multi-node hub pattern.** Each hub instance is responsible
for connecting to a remote node. Input port calls are repeated to
corresponding output ports on a remote hub. These hubs have been
demonstrated on Sockets, ARINC 653 Channels, High-speed hardware bus
between nodes, and UARTs between nodes in an embedded system.
