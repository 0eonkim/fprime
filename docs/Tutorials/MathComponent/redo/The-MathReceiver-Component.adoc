== The MathReceiver Component

Now we build and test the `MathReceiver` component.
We use the same five steps as for the
<<math-sender,`MathSender` component>>.

=== Construct the FPP Model

*Create the MathReceiver directory:*
Create the directory `Ref/MathReceiver`.

*Create the FPP model file:*
In directory `Ref/MathReceiver`, create a file
`MathReceiver.fpp` with the following contents:

[source,fpp]
----
include::../../../../Ref/MathReceiver/MathReceiver.fpp[]
----

This code defines a component `Ref.MathReceiver`.
The component is *queued*, which means it has a queue
but no thread.
Work occurs when the thread of another component invokes
the `schedIn` port of this component.

We have divided the specifiers of this component into six groups:

. *General ports:* There are three ports:
an input port `mathOpIn` for receiving a math operation,
an output port `mathResultOut` for sending a math result, and
an input port `schedIn` for receiving invocations from the scheduler.
`mathOpIn` is asynchronous.
That means invocations of `mathOpIn` put messages on a queue.
`schedIn` is synchronous.
That means invocations of `schedIn` immediately call the
handler function to do work.

. *Special ports:* 
As before, there are special ports for commands, events, telemetry,
and time.
There are also special ports for getting and setting parameters.
We will explain the function of these ports below.

. *Parameters:* There is one *parameter*.
A parameter is a constant that is configurable by command.
In this case there is one parameter `FACTOR`.
It has the default value 1.0 until its value is changed by command.
When doing math, the `MathReceiver` component performs the requested
operation and then multiplies by this factor.
For example, if the arguments of the `mathOpIn` port
are _v1_, `ADD`, and _v2_, and the factor is _f_,
then the result sent on `mathResultOut` is
_(v1 + v2) f_.

. *Events:* There are three event reports:

.. `FACTOR_UPDATED`: Emitted when the `FACTOR` parameter
is updated by command.
This event is *throttled* to a limit of three.
That means that after the event is emitted three times
it will not be emitted any more, until the throttling
is cleared by command (see below).

.. `OPERATION_PERFORMED`: Emitted when this component
performs a math operation.

.. `THROTTLE_CLEARED`: Emitted when the event throttling
is cleared.

. *Commands:* There is one command for clearing
the event throttle.

. *Telemetry:* 
There two telemetry channels: one for reporting
the last operation received and one for reporting
the factor parameter.

For the parameters, events, commands, and telemetry, we chose
to put in all the opcodes and identifiers explicitly.
These can also be left implicit, as in the `MathSender`
component example.
For more information, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components[_The FPP User's Guide_].

=== Add the Model to the Project

Follow the same steps as for the
<<math-sender_add-model,`MathSender` component>>.

=== Build the Stub Implementation

Follow the same steps as for the
<<math-sender_build-stub,`MathSender` component>>.

=== Complete the Implementation

*Fill in the mathOpIn handler:*
In `MathReceiver.cpp`, complete the implementation of
`mathOpIn_handler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  mathOpIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 val1,
      const MathOp& op,
      F32 val2
  )
{

    // Get the initial result
    F32 res = 0.0;
    switch (op.e) {
        case MathOp::ADD:
            res = val1 + val2;
            break;
        case MathOp::SUB:
            res = val1 - val2;
            break;
        case MathOp::MUL:
            res = val1 * val2;
            break;
        case MathOp::DIV:
            res = val1 / val2;
            break;
        default:
            FW_ASSERT(0, op.e);
            break;
    }

    // Get the factor value
    Fw::ParamValid valid;
    F32 factor = paramGet_FACTOR(valid);
    FW_ASSERT(
        valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,
        valid.e
    );

    // Multiply result by factor
    res *= factor;

    // Emit telemetry and events
    this->log_ACTIVITY_HI_OPERATION_PERFORMED(op);
    this->tlmWrite_OPERATION(op);

    // Emit result
    this->mathResultOut_out(0, res);

}
----

This code does the following:

. Compute an initial result based on the input values and
the requested operation.

. Get the value of the factor parameter.
Check that the value is a valid value from the parameter
database or a default parameter value.

. Multiply the initial result by the factor to generate
the final result.

. Emit telemetry and events.

. Emit the result.

Note that in step 1, `op` is an enum (a {cpp} class type), and `op.e`
is the corresponding numeric value (an integer type).
Note also that in the `default` case we deliberately fail
an assertion.
This is a standard pattern for exhaustive case checking.
We should never hit the assertion.
If we do, then a bug has occurred: we missed a case.

*Fill in the schedIn handler:*
In `MathReceiver.cpp`, complete the implementation of
`schedIn_handler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  schedIn_handler(
      const NATIVE_INT_TYPE portNum,
      NATIVE_UINT_TYPE context
  )
{
    U32 numMsgs = this->m_queue.getNumMsgs();
    for (U32 i = 0; i < numMsgs; ++i) {
        (void) this->doDispatch();
    }

}
----

This code dispatches all the messages on the queue.
Note that for a queued component, we have to do this
dispatch explicitly in the `schedIn` handler.
For an active component, the framework auto-generates
the dispatch code.

*Fill in the CLEAR_EVENT_THROTTLE command handler:*
In `MathReceiver.cpp`, complete the implementation of
`CLEAR_EVENT_THROTTLE_cmdHandler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  CLEAR_EVENT_THROTTLE_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq
  )
{
    // clear throttle
    this->log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear();
    // send event that throttle is cleared
    this->log_ACTIVITY_HI_THROTTLE_CLEARED();
    // reply with completion status
    this->cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);
}
----

The call to `log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear` clears
the throttling of the `FACTOR_UPDATED` event.
The next two lines send a notification event and send
a command response.

*Add a parameterUpdated function:*
Add the following function to `MathReceiver.cpp`.
You will need to add the corresponding function header
to `MathReceiver.hpp`.

[source,cpp]
----
void MathReceiver ::
   parameterUpdated(FwPrmIdType id)
{
    switch (id) {
        case PARAMID_FACTOR: {
            Fw::ParamValid valid;
            F32 val = this->paramGet_FACTOR(valid);
            FW_ASSERT(
                valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,
                valid.e
            );
            this->log_ACTIVITY_HI_FACTOR_UPDATED(val);
            break;
        }
        default:
            FW_ASSERT(0, id);
            break;
    }
}
----

This code implements an optional function that, if present,
is called when a parameter is updated by command.
The parameter identifier is passed in as the `id` argument
of the function.
Here we do the following:

. If the parameter identifier is `PARAMID_FACTOR` (the parameter
identifier corresponding to the `FACTOR` parameter,
then get the parameter value and emit an event report.

. Otherwise fail an assertion.
This code should never run, because there are no other
parameters.

=== Write and Run Unit Tests

==== Set up the Unit Test Environment

Follow the same steps as for the
<<math-sender_unit_setup,`MathSender` component>>.

==== Add Helper Code

*Add a ThrottleState enum class:*
Add the following code to the beginning of the
`Tester` class in `Tester.hpp`:

[source,cpp]
----
private:

  // ----------------------------------------------------------------------
  // Types 
  // ----------------------------------------------------------------------
  
  enum class ThrottleState {
    THROTTLED,
    NOT_THROTTLED
  };
----

This code defines a {cpp} enum class for recording whether an
event is throttled.

*Add helper functions:*
For each of the functions described below, you must add 
the corresponding function prototype to `Tester.hpp`.

Add a `setFactor` function in the "Helper methods"
section of  `Tester.cpp`.

[source,cpp]
----
void Tester ::
  setFactor(
      F32 factor,
      ThrottleState throttleState
  )
{
    // clear history
    this->clearHistory();
    // set the parameter
    this->paramSet_FACTOR(factor, Fw::ParamValid::VALID);
    this->paramSend_FACTOR(INSTANCE, CMD_SEQ);
    if (throttleState == ThrottleState::NOT_THROTTLED) {
        // verify the parameter update notification event was sent
        ASSERT_EVENTS_SIZE(1);
        ASSERT_EVENTS_FACTOR_UPDATED_SIZE(1);
        ASSERT_EVENTS_FACTOR_UPDATED(0, factor);
    }
    else {
        ASSERT_EVENTS_SIZE(0);
    }
}
----

This function does the following:

. Clear the test history.

. Send a command to the component to set the `FACTOR` parameter
to the value `factor`.

. If `throttleState` is `NOT_THROTTLED`, then check 
that the event was emitted.
Otherwise check that the event was throttled (not emitted).

Add a function `computeResult` to `Tester.cpp`.

[source,cpp]
----
F32 Tester ::
  computeResult(
      F32 val1,
      MathOp op,
      F32 val2,
      F32 factor
  )
{
    F32 result = 0;
    switch (op.e) {
        case MathOp::ADD:
            result = val1 + val2;
            break;
        case MathOp::SUB:
            result = val1 - val2;
            break;
        case MathOp::MUL:
            result = val1 * val2;
            break;
        case MathOp::DIV:
            result = val1 / val2;
            break;
        default:
            FW_ASSERT(0, op.e);
            break;
    }
    result *= factor;
    return result;
}
----

This function carries out the math computation of the
math component.
By running this function and comparing, we can
check the output of the component.

Add a `doMathOp` function to `Tester.cpp`

[source,cpp]
----
void Tester ::
  doMathOp(
      F32 val1,
      MathOp op,
      F32 val2,
      F32 factor
  )
{

    // clear history
    this->clearHistory();

    // invoke operation port with add operation
    this->invoke_to_mathOpIn(0, val1, op, val2);
    // invoke scheduler port to dispatch message
    this->invoke_to_schedIn(0, 0);

    // verify the result of the operation was returned

    // check that there was one port invocation
    ASSERT_FROM_PORT_HISTORY_SIZE(1);
    // check that the port we expected was invoked
    ASSERT_from_mathResultOut_SIZE(1);
    // check that the component performed the operation correctly
    const F32 result = computeResult(val1, op, val2, factor);
    ASSERT_from_mathResultOut(0, result);

    // verify events

    // check that there was one event
    ASSERT_EVENTS_SIZE(1);
    // check that it was the op event
    ASSERT_EVENTS_OPERATION_PERFORMED_SIZE(1);
    // check that the event has the correct argument
    ASSERT_EVENTS_OPERATION_PERFORMED(0, op);

    // verify telemetry

    // check that one channel was written
    ASSERT_TLM_SIZE(1);
    // check that it was the op channel
    ASSERT_TLM_OPERATION_SIZE(1);
    // check for the correct value of the channel
    ASSERT_TLM_OPERATION(0, op);

}
----

This function is similar to the `doMath` helper function that
we wrote for the `MathSender` component.
Notice that the method for invoking a port is different.
Since the component is queued, we don't call `doDispatch`
directly.
Instead we invoke `schedIn`.

==== Write and Run Tests

For each of the tests described below, you must add the 
corresponding function prototype to `Tester.hpp`
and the corresponding test macro to `main.cpp`.
If you can't remember how to do it, look back at the
`MathSender` examples.
After writing each test, run all the tests and make sure
that they pass.

*Write an ADD test:*
Add the following function to the "Tests" section of `Tester.cpp`:

[source,cpp]
----
void Tester ::
  testAdd()
{
    // Set the factor parameter by command
    const F32 factor = 3.0;
    this->setFactor(factor, ThrottleState::NOT_THROTTLED);
    // Do the add operation
    this->doMathOp(2.0, MathOp::ADD, 3.0, factor);
}
----

This function calls the `setFactor` helper function
to set the factor parameter.
Then it calls the `doMathOp` function to
do a math operation.

*Write a SUB test:*
Add the following function to the "Tests" section of `Tester.cpp`:

[source,cpp]
----
void Tester ::
  testSub()
{
    // Set the factor parameter by loading parameters
    const F32 factor = 3.0;
    this->paramSet_FACTOR(factor, Fw::ParamValid::VALID);
    this->component.loadParameters();
    // Do the operation
    this->doMathOp(2.0, MathOp::SUB, 3.0, factor);
}
----

This test is similar to the ADD command test, but it shows
another way to set a parameter.
The `paramSet` function sets the parameter value in 
the unit test harness.
This part of the harness mimics the behavior of the parameter
database component in flight.
In flight, the function `loadParameters` is typically called at the
start of FSW to load the parameters from the database;
here it loads the parameters from the test harness.
Again we call `doMathOp` to do the operation.

*Write a MUL test:*
This test is the same as the ADD test, except that it
uses MUL instead of add.

*Write a DIV test:*
This test is the same as the SUB test, except that it
uses DIV instead of SUB.

*Write a throttle test:*
Add the following function to the "Tests" section of `Tester.cpp`:

[source,cpp]
----
void Tester ::
  testThrottle()
{

    // send the number of commands required to throttle the event
    // Use the autocoded value so the unit test passes if the
    // throttle value is changed
    for (
        U16 cycle = 0;
        cycle < MathReceiverComponentBase::EVENTID_FACTOR_UPDATED_THROTTLE;
        cycle++
    ) {
        this->setFactor(1.0, ThrottleState::NOT_THROTTLED);
    }

    // Event should now be throttled
    this->setFactor(1.0, ThrottleState::THROTTLED);

    // send the command to clear the throttle
    this->sendCmd_CLEAR_EVENT_THROTTLE(INSTANCE, CMD_SEQ);
    // invoke scheduler port to dispatch message
    this->invoke_to_schedIn(0, 0);
    // verify clear event was sent
    ASSERT_EVENTS_SIZE(1);
    ASSERT_EVENTS_THROTTLE_CLEARED_SIZE(1);

    // Throttling should be cleared
    this->setFactor(1.0, ThrottleState::NOT_THROTTLED);

}
----

This test first loops over the throttle count, which is stored
for us in the constant `EVENTID_FACTOR_UPDATED_THROTTLE`
of the `MathReceiver` component base class.
On each iteration, it calls `setFactor`.
At the end of this loop, the `FACTOR_UPDATED` event should be
throttled.

Next the test calls `setFactor` with a second argument of
`ThrottleState::THROTTLED`.
This code checks that the event is throttled.

Next the test sends the command `CLEAR_EVENT_THROTTLE`,
checks for the corresponding notification event,
and checks that the throttling is cleared.
