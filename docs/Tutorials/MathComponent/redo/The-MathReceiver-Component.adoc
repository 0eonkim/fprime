== The MathReceiver Component

Now we build and test the `MathReceiver` component.
We use the same five steps as for the
<<math-sender,`MathSender` component>>.

=== Construct the FPP Model

*Create the MathReceiver directory:*
Create the directory `Ref/MathReceiver`.

*Create the FPP model file:*
In directory `Ref/MathReceiver`, create a file
`MathReceiver.fpp` with the following contents:

[source,fpp]
----
include::../../../../Ref/MathReceiver/MathReceiver.fpp[]
----

This code defines a component `Ref.MathReceiver`.
The component is *queued*, which means it has a queue
but no thread.
Work occurs when the thread of another component invokes
the `schedIn` port of this component.

We have divided the specifiers of this component into six groups:

. *General ports:* There are three ports:
an input port `mathOpIn` for receiving a math operation,
an output port `mathResultOut` for sending a math result, and
an input port `schedIn` for receiving invocations from the scheduler.
`mathOpIn` is asynchronous.
That means invocations of `mathOpIn` put messages on a queue.
`schedIn` is synchronous.
That means invocations of `schedIn` immediately call the
handler function to do work.

. *Special ports:* 
As before, there are special ports for commands, events, telemetry,
and time.
There are also special ports for getting and setting parameters.
We will explain the function of these ports below.

. *Parameters:* There is one *parameter*.
A parameter is a constant that is configurable by command.
In this case there is one parameter `FACTOR`.
It has the default value 1.0 until its value is changed by command.
When doing math, the `MathReceiver` component performs the requested
operation and then multiplies by this factor.
For example, if the arguments of the `mathOpIn` port
are _v1_, `ADD`, and _v2_, and the factor is _f_,
then the result sent on `mathResultOut` is
_(v1 + v2) f_.

. *Events:* There are three event reports:

.. `FACTOR_UPDATED`: Emitted when the `FACTOR` parameter
is updated by command.
This event is *throttled* to a limit of three.
That means that after the event is emitted three times
it will not be emitted any more, until the throttling
is cleared by command (see below).

.. `OPERATION_PERFORMED`: Emitted when this component
performs a math operation.

.. `THROTTLE_CLEARED`: Emitted when the event throttling
is cleared.

. *Commands:* There is one command for clearing
the event throttle.

. *Telemetry:* 
There two telemetry channels: one for reporting
the last operation received and one for reporting
the factor parameter.

For the parameters, events, commands, and telemetry, we chose
to put in all the opcodes and identifiers explicitly.
These can also be left implicit, as in the `MathSender`
component example.
For more information, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components[_The FPP User's Guide_].

=== Add the Model to the Project

Follow the same steps as for the
<<math-sender_add-model,`MathSender` component>>.

=== Build the Stub Implementation

Follow the same steps as for the
<<math-sender_build-stub,`MathSender` component>>.

=== Complete the Implementation

*Fill in the mathOpIn handler:*
In `MathReceiver.cpp`, complete the implementation of
`mathOpIn_handler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  mathOpIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 val1,
      const MathOp& op,
      F32 val2
  )
{

    // Get the initial result
    F32 res = 0.0;
    switch (op.e) {
        case MathOp::ADD:
            res = val1 + val2;
            break;
        case MathOp::SUB:
            res = val1 - val2;
            break;
        case MathOp::MUL:
            res = val1 * val2;
            break;
        case MathOp::DIV:
            res = val1 / val2;
            break;
        default:
            FW_ASSERT(0, op.e);
            break;
    }

    // Get the factor value
    Fw::ParamValid valid;
    F32 factor = paramGet_FACTOR(valid);
    FW_ASSERT(
        valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,
        valid.e
    );

    // Multiply result by factor
    res *= factor;

    // Emit telemetry and events
    this->log_ACTIVITY_HI_OPERATION_PERFORMED(op);
    this->tlmWrite_OPERATION(op);

    // Emit result
    this->mathResultOut_out(0, res);

}
----

This code does the following:

. Compute an initial result based on the input values and
the requested operation.

. Get the value of the factor parameter.
Check that the value is a valid value from the parameter
database or a default parameter value.

. Multiply the initial result by the factor to generate
the final result.

. Emit telemetry and events.

. Emit the result

Note that in step 1, `op` is an enum (a {cpp} class type) and `op.e`
is the corresponding numeric value (an integer type).
Note also that in the `default` case we deliberately fail
an assertion.
This is a standard pattern for exhaustive case checking.
We should never hit the assertion.
If we do, then a bug has occurred: we missed a case.

*Fill in the schedIn handler:*
In `MathReceiver.cpp`, complete the implementation of
`schedIn_handler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  schedIn_handler(
      const NATIVE_INT_TYPE portNum,
      NATIVE_UINT_TYPE context
  )
{
    U32 numMsgs = this->m_queue.getNumMsgs();
    for (U32 i = 0; i < numMsgs; ++i) {
        (void) this->doDispatch();
    }

}
----

This code dispatches all the messages on the queue.
Note that for a queued component, we have to do this
dispatch explicitly in the `schedIn` handler.
For an active component, the framework auto-generates
the dispatch code.

*Fill in the CLEAR_EVENT_THROTTLE command handler:*
In `MathReceiver.cpp`, complete the implementation of
`CLEAR_EVENT_THROTTLE_cmdHandler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  CLEAR_EVENT_THROTTLE_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq
  )
{
    // clear throttle
    this->log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear();
    // send event that throttle is cleared
    this->log_ACTIVITY_HI_THROTTLE_CLEARED();
    // reply with completion status
    this->cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);
}
----

The call to `log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear` clears
the throttling of the `FACTOR_UPDATED` event.
The next two lines send a notification event and send
a command response.

*Add a parameterUpdated function:*
Add the following function to `MathReceiver.cpp`.
You will need to add the corresponding function header
to `MathReceiver.hpp`.

[source,cpp]
----
void MathReceiver ::
   parameterUpdated(FwPrmIdType id)
{
    switch (id) {
        case PARAMID_FACTOR: {
            Fw::ParamValid valid;
            F32 val = this->paramGet_FACTOR(valid);
            FW_ASSERT(
                valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,
                valid.e
            );
            this->log_ACTIVITY_HI_FACTOR_UPDATED(val);
            break;
        }
        default:
            FW_ASSERT(0, id);
            break;
    }
}
----

This code implements an optional function that, if present,
is called when a parameter is updated by command.
The parameter identifier is passed in as the `id` argument
of the function.
Here we do the following:

. If the parameter identifier is `PARAMID_FACTOR` (the parameter
identifier corresponding to the `FACTOR` parameter,
then get the parameter value and emit an event report.

. Otherwise fail an assertion.
This code should never run, because there are no other
parameters.

=== Write and Run Unit Tests

TODO
