== The MathReceiver Component

Now we will build and test the `MathReceiver` component.
We will use the same five steps as for the
<<math-sender,`MathSender` component>>.

=== Construct the FPP Model

*Create the MathReceiver directory:*
Create the directory `Ref/MathReceiver`.

*Create the FPP model file:*
In directory `Ref/MathReceiver`, create a file
`MathReceiver.fpp` with the following contents:

[source,fpp]
----
include::../../../../Ref/MathReceiver/MathReceiver.fpp[]
----

This code defines a component `Ref.MathReceiver`.
The component is *queued*, which means it has a queue
but no thread.
Work occurs when the thread of another component invokes
the `schedIn` port of this component.

We have divided the specifiers of this component into six groups:

. *General ports:* There are three ports:
an input port `mathOpIn` for receiving a math operation,
an output port `mathResultOut` for sending a math result, and
an input port `schedIn` for receiving invocations from the scheduler.
`mathOpIn` is asynchronous.
That means invocations of `mathOpIn` put messages on a queue.
`schedIn` is synchronous.
That means invocations of `schedIn` immediately call the
handler function to do work.

. *Special ports:* 
As before, there are special ports for commands, events, telemetry,
and time.
There are also special ports for getting and setting parameters.
We will explain the function of these ports below.

. *Parameters:* There is one *parameter*.
A parameter is a constant that is configurable by command.
In this case there is one parameter `FACTOR`.
It has the default value 1.0 until its value is changed by command.
When doing math, the `MathReceiver` component performs the requested
operation and then multiplies by this factor.
For example, if the arguments of the `mathOpIn` port
are _v1_, `ADD`, and _v2_, and the factor is _f_,
then the result sent on `mathResultOut` is
_(v1 + v2) f_.

. *Events:* There are three event reports:

.. `FACTOR_UPDATED`: Emitted when the `FACTOR` parameter
is updated by command.
This event is *throttled* to a limit of three.
That means that after the event is emitted three times
it will not be emitted any more, until the throttling
is cleared by command (see below).

.. `OPERATION_PERFORMED`: Emitted when this component
performs a math operation.

.. `THROTTLE_CLEARED`: Emitted when the event throttling
is cleared.

. *Commands:* There is one command for clearing
the event throttle.

. *Telemetry:* 
There two telemetry channels: one for reporting
the last operation received and one for reporting
the factor parameter.

For the parameters, events, commands, and telemetry, we chose
to put in all the opcodes and identifiers explicitly.
These can also be left implicit, as in the `MathSender`
component example.
For more information, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components[_The FPP User's Guide_].

=== Add the Model to the Project

Follow the steps given for the
<<math-sender_add-model,`MathSender` component>>.

=== Build the Stub Implementation

Follow the same steps as for the
<<math-sender_build-stub,`MathSender` component>>.

=== Complete the Implementation

*Fill in the mathOpIn handler:*
In `MathReceiver.cpp`, complete the implementation of
`mathOpIn_handler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  mathOpIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 val1,
      const MathOp& op,
      F32 val2
  )
{

    // Get the initial result
    F32 res = 0.0;
    switch (op.e) {
        case MathOp::ADD:
            res = val1 + val2;
            break;
        case MathOp::SUB:
            res = val1 - val2;
            break;
        case MathOp::MUL:
            res = val1 * val2;
            break;
        case MathOp::DIV:
            res = val1 / val2;
            break;
        default:
            FW_ASSERT(0, op.e);
            break;
    }

    // Get the factor value
    Fw::ParamValid valid;
    F32 factor = paramGet_FACTOR(valid);
    FW_ASSERT(
        valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,
        valid.e
    );

    // Multiply result by factor
    res *= factor;

    // Emit telemetry and events
    this->log_ACTIVITY_HI_OPERATION_PERFORMED(op);
    this->tlmWrite_OPERATION(op);

    // Emit result
    this->mathResultOut_out(0, res);

}
----

This code does the following:

. Compute an initial result based on the input values and
the requested operation.

. Get the value of the factor parameter.
Check that the value is a valid value from the parameter
database or a default parameter value.

. Multiply the initial result by the factor to generate
the final result.

. Emit telemetry and events.

. Emit the result.

Note that in step 1, `op` is an enum (a {cpp} class type), and `op.e`
is the corresponding numeric value (an integer type).
Note also that in the `default` case we deliberately fail
an assertion.
This is a standard pattern for exhaustive case checking.
We should never hit the assertion.
If we do, then a bug has occurred: we missed a case.

*Fill in the schedIn handler:*
In `MathReceiver.cpp`, complete the implementation of
`schedIn_handler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  schedIn_handler(
      const NATIVE_INT_TYPE portNum,
      NATIVE_UINT_TYPE context
  )
{
    U32 numMsgs = this->m_queue.getNumMsgs();
    for (U32 i = 0; i < numMsgs; ++i) {
        (void) this->doDispatch();
    }
}
----

This code dispatches all the messages on the queue.
Note that for a queued component, we have to do this
dispatch explicitly in the `schedIn` handler.
For an active component, the framework auto-generates
the dispatch code.

*Fill in the CLEAR_EVENT_THROTTLE command handler:*
In `MathReceiver.cpp`, complete the implementation of
`CLEAR_EVENT_THROTTLE_cmdHandler` so that it looks like this:

[source,cpp]
----
void MathReceiver ::
  CLEAR_EVENT_THROTTLE_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq
  )
{
    // clear throttle
    this->log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear();
    // send event that throttle is cleared
    this->log_ACTIVITY_HI_THROTTLE_CLEARED();
    // reply with completion status
    this->cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);
}
----

The call to `log_ACTIVITY_HI_FACTOR_UPDATED_ThrottleClear` clears
the throttling of the `FACTOR_UPDATED` event.
The next two lines send a notification event and send
a command response.

*Add a parameterUpdated function:*
Add the following function to `MathReceiver.cpp`.
You will need to add the corresponding function header
to `MathReceiver.hpp`.

[source,cpp]
----
void MathReceiver ::
   parameterUpdated(FwPrmIdType id)
{
    switch (id) {
        case PARAMID_FACTOR: {
            Fw::ParamValid valid;
            F32 val = this->paramGet_FACTOR(valid);
            FW_ASSERT(
                valid.e == Fw::ParamValid::VALID || valid.e == Fw::ParamValid::DEFAULT,
                valid.e
            );
            this->log_ACTIVITY_HI_FACTOR_UPDATED(val);
            break;
        }
        default:
            FW_ASSERT(0, id);
            break;
    }
}
----

This code implements an optional function that, if present,
is called when a parameter is updated by command.
The parameter identifier is passed in as the `id` argument
of the function.
Here we do the following:

. If the parameter identifier is `PARAMID_FACTOR` (the parameter
identifier corresponding to the `FACTOR` parameter,
then get the parameter value and emit an event report.

. Otherwise fail an assertion.
This code should never run, because there are no other
parameters.

=== Write and Run Unit Tests

==== Set up the Unit Test Environment

. Follow the steps given for the
<<math-sender_unit_setup,`MathSender` component>>.

. Follow the steps given under *Modifying the code*
for the
<<math-sender_exercise,random testing exercise>>,
so that you can use STest to pick random values.

==== Add Helper Code

*Add a ThrottleState enum class:*
Add the following code to the beginning of the
`Tester` class in `Tester.hpp`:

[source,cpp]
----
private:

  // ----------------------------------------------------------------------
  // Types 
  // ----------------------------------------------------------------------
  
  enum class ThrottleState {
    THROTTLED,
    NOT_THROTTLED
  };
----

This code defines a {cpp} enum class for recording whether an
event is throttled.

*Add helper functions:*
Add each of the functions described below to the
"Helper methods" section of `Tester.cpp`.
For each function, you must add
the corresponding function prototype to `Tester.hpp`.
After adding each function, compile the unit tests
to make sure that everything still compiles.
Fix any errors that occur.

Add a `pickF32Value` function.

[source,cpp]
----
F32 Tester ::
  pickF32Value()
{
  const F32 m = 10e6;
  return m * (1.0 - 2 * STest::Pick::inUnitInterval());
}
----

This function picks a random `F32` value in the range
_[ -10^6, 10^6 ]_.

Add a `setFactor` function.

[source,cpp]
----
void Tester ::
  setFactor(
      F32 factor,
      ThrottleState throttleState
  )
{
    // clear history
    this->clearHistory();
    // set the parameter
    this->paramSet_FACTOR(factor, Fw::ParamValid::VALID);
    const U32 instance = STest::Pick::any();
    const U32 cmdSeq = STest::Pick::any();
    this->paramSend_FACTOR(instance, cmdSeq);
    if (throttleState == ThrottleState::NOT_THROTTLED) {
        // verify the parameter update notification event was sent
        ASSERT_EVENTS_SIZE(1);
        ASSERT_EVENTS_FACTOR_UPDATED_SIZE(1);
        ASSERT_EVENTS_FACTOR_UPDATED(0, factor);
    }
    else {
        ASSERT_EVENTS_SIZE(0);
    }
}
----

This function does the following:

. Clear the test history.

. Send a command to the component to set the `FACTOR` parameter
to the value `factor`.

. If `throttleState` is `NOT_THROTTLED`, then check 
that the event was emitted.
Otherwise check that the event was throttled (not emitted).

Add a function `computeResult` to `Tester.cpp`.

[source,cpp]
----
F32 Tester ::
  computeResult(
      F32 val1,
      MathOp op,
      F32 val2,
      F32 factor
  )
{
    F32 result = 0;
    switch (op.e) {
        case MathOp::ADD:
            result = val1 + val2;
            break;
        case MathOp::SUB:
            result = val1 - val2;
            break;
        case MathOp::MUL:
            result = val1 * val2;
            break;
        case MathOp::DIV:
            result = val1 / val2;
            break;
        default:
            FW_ASSERT(0, op.e);
            break;
    }
    result *= factor;
    return result;
}
----

This function carries out the math computation of the
math component.
By running this function and comparing, we can
check the output of the component.

Add a `doMathOp` function to `Tester.cpp`.

[source,cpp]
----
void Tester ::
  doMathOp(
      MathOp op,
      F32 factor
  )
{

    // pick values
    const F32 val1 = pickF32Value();
    const F32 val2 = pickF32Value();

    // clear history
    this->clearHistory();

    // invoke operation port with add operation
    this->invoke_to_mathOpIn(0, val1, op, val2);
    // invoke scheduler port to dispatch message
    const U32 context = STest::Pick::any();
    this->invoke_to_schedIn(0, context);

    // verify the result of the operation was returned

    // check that there was one port invocation
    ASSERT_FROM_PORT_HISTORY_SIZE(1);
    // check that the port we expected was invoked
    ASSERT_from_mathResultOut_SIZE(1);
    // check that the component performed the operation correctly
    const F32 result = computeResult(val1, op, val2, factor);
    ASSERT_from_mathResultOut(0, result);

    // verify events

    // check that there was one event
    ASSERT_EVENTS_SIZE(1);
    // check that it was the op event
    ASSERT_EVENTS_OPERATION_PERFORMED_SIZE(1);
    // check that the event has the correct argument
    ASSERT_EVENTS_OPERATION_PERFORMED(0, op);

    // verify telemetry

    // check that one channel was written
    ASSERT_TLM_SIZE(1);
    // check that it was the op channel
    ASSERT_TLM_OPERATION_SIZE(1);
    // check for the correct value of the channel
    ASSERT_TLM_OPERATION(0, op);

}
----

This function is similar to the `doMath` helper function that
we wrote for the `MathSender` component.
Notice that the method for invoking a port is different.
Since the component is queued, we don't call `doDispatch`
directly.
Instead we invoke `schedIn`.

==== Write and Run Tests

For each of the tests described below, you must add the 
corresponding function prototype to `Tester.hpp`
and the corresponding test macro to `main.cpp`.
If you can't remember how to do it, look back at the
`MathSender` examples.
After writing each test, run all the tests and make sure
that they pass.

*Write an ADD test:*
Add the following function to the "Tests" section of `Tester.cpp`:

[source,cpp]
----
void Tester ::
  testAdd()
{
    // Set the factor parameter by command
    const F32 factor = pickF32Value();
    this->setFactor(factor, ThrottleState::NOT_THROTTLED);
    // Do the add operation
    this->doMathOp(MathOp::ADD, factor);
}
----

This function calls the `setFactor` helper function
to set the factor parameter.
Then it calls the `doMathOp` function to
do a math operation.

*Write a SUB test:*
Add the following function to the "Tests" section of `Tester.cpp`:

[source,cpp]
----
void Tester ::
  testSub()
{
    // Set the factor parameter by loading parameters
    const F32 factor = pickF32Value();
    this->paramSet_FACTOR(factor, Fw::ParamValid::VALID);
    this->component.loadParameters();
    // Do the operation
    this->doMathOp(MathOp::SUB, factor);
}
----

This test is similar to `testAdd`, but it shows
another way to set a parameter.
`testAdd` showed how to set a parameter by command.
You can also set a parameter by initialization, as follows:

. Call the `paramSet` function as shown.
This function sets the parameter value in 
the part of the test harness that mimics the behavior of the
parameter database component.

. Call the `loadParameters` function as shown.
In flight, the function `loadParameters` is typically called at the
start of FSW to load the parameters from the database;
here it loads the parameters from the test harness.
There is no command to update a parameter, so `parameterUpdated`
is not called, and no event is emitted.

As before, after setting the parameter we call `doMathOp`
to do the operation.

*Write a MUL test:*
This test is the same as the ADD test, except that it
uses MUL instead of add.

*Write a DIV test:*
This test is the same as the SUB test, except that it
uses DIV instead of SUB.

*Write a throttle test:*
Add the following function to the "Tests" section of `Tester.cpp`:

[source,cpp]
----
void Tester ::
  testThrottle()
{

    // send the number of commands required to throttle the event
    // Use the autocoded value so the unit test passes if the
    // throttle value is changed
    const F32 factor = pickF32Value();
    for (
        U16 cycle = 0;
        cycle < MathReceiverComponentBase::EVENTID_FACTOR_UPDATED_THROTTLE;
        cycle++
    ) {
        this->setFactor(factor, ThrottleState::NOT_THROTTLED);
    }

    // Event should now be throttled
    this->setFactor(factor, ThrottleState::THROTTLED);

    // send the command to clear the throttle
    this->sendCmd_CLEAR_EVENT_THROTTLE(INSTANCE, CMD_SEQ);
    // invoke scheduler port to dispatch message
    const U32 context = STest::Pick::any();
    this->invoke_to_schedIn(0, context);
    // verify clear event was sent
    ASSERT_EVENTS_SIZE(1);
    ASSERT_EVENTS_THROTTLE_CLEARED_SIZE(1);

    // Throttling should be cleared
    this->setFactor(factor, ThrottleState::NOT_THROTTLED);

}
----

This test first loops over the throttle count, which is stored
for us in the constant `EVENTID_FACTOR_UPDATED_THROTTLE`
of the `MathReceiver` component base class.
On each iteration, it calls `setFactor`.
At the end of this loop, the `FACTOR_UPDATED` event should be
throttled.

Next the test calls `setFactor` with a second argument of
`ThrottleState::THROTTLED`.
This code checks that the event is throttled.

Next the test sends the command `CLEAR_EVENT_THROTTLE`,
checks for the corresponding notification event,
and checks that the throttling is cleared.

=== Reference Implementation

A reference implementation for this section is available at
`docs/Tutorials/MathComponent/MathReceiver`.

=== Exercises

==== Adding Telemetry

Add a telemetry channel that records the number of math
operations performed.

. Add the channel to the FPP model.

. In the component implementation class, add a member
variable `num_math_ops` of type `U32`.
Initialize the variable to zero in the class constructor.

. Revise the `mathOpIn` handler so that it increments
`num_math_ops` and emits the updated value as telemetry.

. Revise the unit tests to cover the new behavior.

==== Error Handling

Think about what will happen if the floating-point
math operation performed by `MathReceiver` causes an error.
For example, suppose that `mathOpIn` is invoked with `op = DIV`
and `val2 = 0.0`.
What will happen?
As currently designed and implemented, the `MathReceiver`
component will perform the requested operation.
On most systems the result will be `INF` (floating-point infinity).
In this case, the result will be sent back to `MathSender`
and reported in the usual way.
On some systems, the hardware could issue a floating-point exception.

Suppose you wanted to handle the case of division by zero
explicitly.
How would you change the design?
Here are some questions to think about:

. How would you check for division by zero?
Note that `val2 = 0.0` is not the only case in which a division
by zero error can occur.
It can also occur for very small values of `val2`.

. Should the error be caught in `MathSender` or `MathReceiver`?

. Suppose the design says that `MathSender` catches the error,
and so never sends requests to `MathReceiver` to divide by zero.
what if anything should `MathReceiver` do if it receives
a divide by zero request?
Carry out the operation normally?
Emit a warning?
Fail a FSW assertion?

. If the error is caught by `MathReceiver`, does the
interface between the components have to change?
If so, how?
What should `MathSender` do if `MathReceiver`
reports an error instead of a valid result?

Revise the MathSender and MathReceiver components to implement your
ideas.
Add unit tests covering the new behavior.
