== The MathSender Component

Now we can build and test the `MathSender` component.
There are five steps:

. Construct the FPP model.
. Add the model to the project.
. Build the stub implementation.
. Complete the implementation.
. Write and run unit tests.

=== Construct the FPP Model

*In directory Ref:*
Go to the directory `Ref` at the top-level of the
F Prime repository.
Run `mkdir MathSender` to create a directory for the new component.

*In directory Ref/MathSender:*
Now go into the directory `Ref/MathSender`.
Create a file `MathSender.fpp` with the following contents:

[source,fpp]
----
include::../../../../Ref/MathSender/MathSender.fpp[]
----

This code defines a component `Ref.MathSender`.
The component is *active*, which means it has its
own thread.

Inside the definition of the `MathSender` component are
several specifiers.
We have divided the specifiers into five groups:

. *General ports:* These are user-defined ports for
application-specific functions.
There are two general ports: an output port `mathOpOut`
of type `MathOp` and an input port `mathResultIn` of
type `MathResult`.
Notice that these port specifiers use the ports that
we defined <<ports,above>>.
The input port is *asynchronous*.
This means that when the port is invoked (i.e., when
data is sent on the port) a message is placed on a queue,
and its handler is later run on the thread of this component.

. *Special ports:* These are ports that have a special
meaning in F Prime.
There are ports for registering commands with the dispatcher,
receiving commands, sending command responses, emitting
event reports, emitting telemetry, and getting the time.

. *Commands:* These are commands sent from the ground
or from a sequencer and dispatched to this component.
There is one command `DO_MATH` for doing a math operation.
The command is asynchronous.
This means that when the command arrives, it goes on a queue
and its handler is later run on the thread of this component.

. *Events:* These are event reports that this component
can emit.
There are two event reports, one for receiving a command
and one for receiving a result.

. *Telemetry:* These are *channels* that define telemetry
points that the this component can emit.
There are four telemetry channels: three for the arguments
to the last command received and one for the last
result received.

For more information on defining components, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components[_The FPP User's Guide_].

=== Add the Model to the Project

*In directory Ref/MathSender:*
Create a file `Ref/MathSender/CMakeLists.txt` with the following contents:

[source,cmake]
----
# Register the standard build
set(SOURCE_FILES
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.cpp"
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.fpp"
)
register_fprime_module()
----

This code will tell the build system how to build the FPP model
and component implementation.

*In directory Ref:*
Add `Ref/MathTypes` to `Ref/CMakeLists.txt`, as we did
for the <<types-add,`MathOp` type>>.

=== Build the Stub Implementation

*In directory Ref/MathTypes:*
Go into the directory `Ref/MathTypes`.
Run the command `fprime-util impl`.
The build system should
run for a bit. At the end there should be two new files
in the directory: 
`MathSenderComponentImpl.cpp-template` and
`MathSenderComponentImpl.hpp-template`.
Run the following commands:

[source,bash]
----
mv MathSenderComponentImpl.cpp-template MathSender.cpp
mv MathSenderComponentImpl.hpp-template MathSender.hpp
----

These commands produce a template, or stub implementation,
of the `MathSender` implementation class.
You will fill in this implementation class below.

Now run the command `fprime-util build`.
The model and the stub implementation should build.

*In directory Ref/build-fprime-automatic-native/Ref/MathSender:*
The generated code resides in this directory.
You may wish to look over the file `MathSenderComponentAc.hpp`
to get an idea of the interface to the auto-generated
base class `MathSenderComponentBase`.
The `MathSender` implementation class is a derived class
of this base class.

=== Complete the Implementation

Now we can complete the stub implementation.
In an editor, open the file `MathSender.cpp`.

*Fill in the DO_MATH command handler:*
You should see a stub handler for the `DO_MATH`
command that looks like this:

[source,c++]
----
void MathSender ::
  DO_MATH_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq,
      F32 val1,
      MathOp op,
      F32 val2
  )
{
  // TODO
  this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::OK);
}
----

The handler `DO_MATH_handler` is called when the `MathSender`
component receives a `DO_MATH` command.
This handler overrides the corresponding pure virtual
function in the auto-generated base class.
Fill in the handler so that it looks like this:

[source,c++]
----
void MathSender ::
  DO_MATH_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq,
      F32 val1,
      MathOp op,
      F32 val2
  )
{
  this->tlmWrite_VAL1(val1);
  this->tlmWrite_OP(op);
  this->tlmWrite_VAL2(val2);
  this->log_ACTIVITY_LO_COMMAND_RECV(val1, op, val2);
  this->mathOpOut_out(0, val1, op, val2);
  this->cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);
}
----

The first two arguments to the handler function provide
the command opcode and the command sequence number
(a unique identifier generated by the command dispatcher).
The remaining arguments are supplied when the command is sent,
for example, from the F Prime ground data system (GDS).
The implementation code does the following:

. Emit telemetry and events.
. Invoke the `mathOpOut` port to request that `MathReceiver`
perform the operation.
. Send a command response indicating success.
The command response goes out on the special port
`cmdResponseOut`.

*Check the build:*
Run `fprime-util build` again to make sure that everything still builds.

*Fill in the mathResultIn handler:*
You should see a stub handler for the `mathResultIn`
port that looks like this:

[source,c++]
----
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
  // TODO
}
----

The handler `mathResultIn_handler` is called when the `MathReceiver`
component code returns a result by invoking the `mathResultIn` port.
Again the handler overrides the corresponding pure virtual
function in the auto-generated base class.
Fill in the handler so that it looks like this:

[source,c++]
----
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
    this->tlmWrite_RESULT(result);
    this->log_ACTIVITY_HI_RESULT(result);
}
----

The implementation code emits the result on the `RESULT`
telemetry channel and as a `RESULT` event report.

*Check the build:*
Run `fprime-util build`.

=== Write and Run Unit Tests

*Unit tests* are an important part of FSW development.
At the component level, unit tests typically invoke input ports, send commands, 
and check for expected values on output ports (including telemetry and event
ports).

We will carry out the unit testing for the `MathSender` component
in three steps:

. Set up the unit test environment
. Write and run one unit test
. Write and run additional unit tests

==== Set Up the Unit Test Environment

*In directory Ref/MathSender*:
Do the following:

. Run `mkdir -p test/ut` to create the directory where
the unit tests will reside.

. Run the command `fprime-util impl --ut`.
It should generate files `Tester.cpp` and `Tester.hpp`.

. Move these files to the `test/ut` directory:

+
[source,bash]
----
mv Tester.* test/ut
----

*In directory Ref/MathSender/test/ut:*
Now go to the directory `Ref/MathSender/test/ut`.
In that directory, create a file `main.cpp` with the
following contents:

[source,c++]
----
#include "Tester.hpp"

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
----

This file is a stub for running tests using the
https://github.com/google/googletest[Google Test framework]. 
Right now there aren't any tests to run; we will add one
in the next section.

*In directory Ref/MathSender:*
Go back to the directory `Ref/MathSender`.
Add the following lines to `CMakeLists.txt`:

[source,cmake]
----
# Register the unit test build
set(UT_SOURCE_FILES
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.fpp"
  "${CMAKE_CURRENT_LIST_DIR}/test/ut/Tester.cpp"
  "${CMAKE_CURRENT_LIST_DIR}/test/ut/main.cpp"
)
register_fprime_ut()
----

This code tells the build system how to build
and run the unit tests.

Now we can check that the unit test build is working.

. If you have not yet run `fprime-util generate --ut`,
then do so now.
This step generates the CMake build cache for the unit
tests.

. Run `fprime-util build --ut`.
Everything should build without errors.

The generated code is located at `
`Ref/build-fprime-automatic-native-ut/Ref/MathSender`.
This directory contains two auto-generated classes:

. `MathSenderGTestBase`: This is the direct base
class of `Tester`.
It provides a test interface implemented with GoogleTest
macros.

. `MathSenderTesterBase`: This is the direct base
class of `MathSenderGTestBase`.
It provides basic features such as histories of port
invocations.
It is not specific to Google Test, so that one may
use this class without Google Test if desired.

==== Write and Run One Unit Test

Now we will write a unit test that exercises the
`DO_MATH` command.
We will do this in three phases:

. In the `Tester` class, add a helper function for sending the command and
checking the responses.
That way multiple tests can reuse the same code.

. In the `Tester` class, write a test function that
calls the helper to run a test.

. In the `main` function, write a Google Test macro
that invokes the test function.

. Run the test.

*Add a helper function:*
Go into the directory `Ref/MathSender/test/ut`.
In the file `Tester.hpp`, add the following lines
to the section entitled "Helper methods":

[source,c++]
----
//! Test a DO_MATH command
void testDoMath(
    F32 val1,
    MathOp op,
    F32 val2
);
----

In the file `Tester.cpp`, add the corresponding
function body:

[source,c++]
----
void Tester ::
  testDoMath(
      F32 val1,
      MathOp op,
      F32 val2
  )
{

    // Send the command

    // synthesize a command sequence number
    const U32 cmdSeq = 10;
    // send MS_DO_MATH command
    this->sendCmd_DO_MATH(0, cmdSeq, val1, op, val2);
    // retrieve the message from the message queue and dispatch the command to the handler
    this->component.doDispatch();

    // Verify command receipt and response

    // verify command response was sent
    ASSERT_CMD_RESPONSE_SIZE(1);
    // verify the command response was correct as expected
    ASSERT_CMD_RESPONSE(0, MathSenderComponentBase::OPCODE_DO_MATH, cmdSeq, Fw::CmdResponse::OK);

    // Verify operation request on mathOpOut

    // verify that that one output port was invoked overall
    ASSERT_FROM_PORT_HISTORY_SIZE(1);
    // verify that the math operation port was invoked once
    ASSERT_from_mathOpOut_SIZE(1);
    // verify the arguments of the operation port
    ASSERT_from_mathOpOut(0, val1, op, val2);

    // Verify telemetry

    // verify that 3 channels were written
    ASSERT_TLM_SIZE(3);
    // verify that the desired telemetry values were only sent once
    ASSERT_TLM_VAL1_SIZE(1);
    ASSERT_TLM_VAL2_SIZE(1);
    ASSERT_TLM_OP_SIZE(1);
    // verify that the correct telemetry values were sent
    ASSERT_TLM_VAL1(0, val1);
    ASSERT_TLM_VAL2(0, val2);
    ASSERT_TLM_OP(0, op);

    // Verify event reports

    // verify that one event was sent
    ASSERT_EVENTS_SIZE(1);
    // verify the expected event was only sent once
    ASSERT_EVENTS_COMMAND_RECV_SIZE(1);
    // verify the correct event arguments were sent
    ASSERT_EVENTS_COMMAND_RECV(0, val1, op, val2);

}
----

This function is parameterized over different operand values
and operations.
It is divided into five sections: sending the command,
checking the command response, checking the output on
`mathOpOut`, checking telemetry, and checking events.
The comments explain what is happening in each section.
For further information about the F Prime unit test
interface, see the F Prime User's Guide.

*Write a test function:*
Next we will write a test function that calls
`testDoMath` to test an `ADD` operation.
In `Tester.hpp`, add the following line in the
section entitled "Tests":

[source,c++]
----
//! Test an add command
void testAddCommand();
----

TODO

*Write a test macro:*
TODO

*Run the test:*
TODO

==== Write and Run Additional Unit Tests

TODO
