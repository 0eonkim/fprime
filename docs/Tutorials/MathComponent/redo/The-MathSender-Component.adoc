== The MathSender Component

Now we can build and test the `MathSender` component.
There are five steps:

. Construct the FPP model.
. Add the model to the project.
. Build the model.
. Complete the implementation.
. Write and run unit tests.

=== Construct the FPP Model

*In directory Ref:*
Go to the directory `Ref` at the top-level of the
F Prime repository.
Run `mkdir MathSender` to create a directory for the new component.

*In directory Ref/MathSender:*
Now go into the directory `Ref/MathSender`.
Create a file `MathSender.fpp` with the following contents:

[source,fpp]
----
include::../../../../Ref/MathSender/MathSender.fpp[]
----

This code defines a component `Ref.MathSender`.
The component is *active*, which means it has its
own thread.

Inside the definition of the `MathSender` component are
several specifiers.
We have divided the specifiers into five groups:

. *General ports:* These are user-defined ports for
application-specific functions.
There are two general ports: an output port `mathOpOut`
of type `MathOp` and an input port `mathResultIn` of
type `MathResult`.
Notice that these port specifiers use the ports that
we defined above.
The input port is *asynchronous*.
This means that when the port is invoked (i.e., when
data is sent on the port) a message is placed on a queue,
and its handler is later run on the thread of this component.

. *Special ports:* These are ports that have a special
meaning in F Prime.
There are ports for registering commands with the dispatcher,
receiving commands, sending command responses, emitting
event reports, emitting telemetry, and getting the time.

. *Commands:* These are commands sent from the ground
or from a sequencer and dispatched to this component.
There is one command `DO_MATH` for doing a math operation.
The command is asynchronous.
This means that when the command arrives, it goes on a queue
and its handler is later run on the thread of this component.

. *Events:* These are event reports that this component
can emit.
There are two event reports, one for receiving a command
and one for receiving a result.

. *Telemetry:* These are *channels* that define telemetry
points that the this component can emit.
There are four telemetry channels: three for the arguments
to the last command received and one for the last
result received.

For more information on defining components, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components[_The FPP User's Guide_].

=== Add the Model to the Project

*In directory Ref/MathSender:*
Create a file `Ref/MathSender/CMakeLists.txt` with the following contents:

[source,cmake]
----
# Register the standard build
set(SOURCE_FILES
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.cpp"
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.fpp"
)
register_fprime_module()
----

This code will tell the build system how to build the FPP model
and component implementation.

*In directory Ref:*
Add `Ref/MathTypes` to `Ref/CMakeLists.txt`, as we did
for the <<types-add,`MathOp` type>>.

=== Build the Model

*In directory Ref/MathTypes:*
Go into the directory `Ref/MathTypes`.
Run the command `fprime-util impl`.
The build system should
run for a bit. At the end there should be two new files
in the directory: 
`MathSenderComponentImpl.cpp-template` and
`MathSenderComponentImpl.hpp-template`.
Run the following commands:

[source,bash]
----
mv MathSenderComponentImpl.cpp-template MathSender.cpp
mv MathSenderComponentImpl.hpp-template MathSender.hpp
----

These commands produce a template, or stub implementation,
of the `MathSender` implementation class.
You will fill in this implementation class below.

Now run the command `fprime-util build`.
The model and the stub implementation should build.

*In directory Ref/build-fprime-automatic-native/Ref/MathSender:*
The generated code resides in this directory.
You may wish to look over the file `MathSenderComponentAc.hpp`
to get an idea of the interface to the auto-generated
base class `MathSenderComponentBase`.
The `MathSender` implementation class is a derived class
of this base class.

=== Complete the Implementation

Now we can complete the stub implementation.
In an editor, open the file `MathSender.cpp`.

*Fill in the mathResultIn handler:*
You should see a stub handler for the `mathResultIn`
port that looks like this:

[source,c++]
----
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
  // TODO
}
----

This handler overrides the corresponding pure virtual
function in the auto-generated base class.
Fill in the handler so that it looks like this:

[source,c++]
----
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
    this->tlmWrite_RESULT(result);
    this->log_ACTIVITY_HI_RESULT(result);
}
----

This port handler is called when the `MathReceiver` component
code returns a result.
The implementation code emits the result on the `RESULT`
telemetry channel and as a `RESULT` event report.

*Fill in the DO_MATH command handler:*

TODO

=== Write and Run Unit Tests

TODO
