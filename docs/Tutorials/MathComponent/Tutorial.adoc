= Math Component Tutorial
:toc: left
:toclevels: 3

== Introduction

This tutorial shows how to develop and test a simple topology
consisting of two components:

. `MathSender`: A component that receives commands and forwards work to `MathReceiver`.
. `MathReceiver`: A component that carries out arithmetic operations and returns the results
to `MathSender`.

See the diagram below.

.A simple topology for arithmetic computation
image::img/top.png[Math Sender and Math Receiver]

*What is covered:* The tutorial covers the following concepts:

. Using the https://fprime-community.github.io/fpp[FPP modeling language]
and the F Prime CMake build system to specify the types and ports used by the components.
. Developing the MathSender component: Using FPP and CMake to specify the component,
completing the {cpp} component implementation, and writing
component unit tests.
. Developing the MathReceiver component.
. Adding the new components and connections to the topology for the F Prime
`Ref` application.
. Using the F Prime Ground Data System (GDS) to run the updated `Ref`
application.

*Prerequisites:* This tutorial assumes the following:

. Basic knowledge of Unix: how to navigate in a shell and execute programs.
. Basic knowledge of git: How to create a branch.
. Basic knowledge of {cpp}, including class declarations and inheritance.

If you have not yet installed F Prime on your system, do so now.
Follow the installation guide at `INSTALL.md`
in the https://github.com/nasa/fprime[F Prime git repository].
You may also wish to work through the Getting Started tutorial at
`docs/GettingStarted/Tutorial.md`.

*Git branch:* This tutorial is designed to work on the branch `release/v3.0.0`.

Working on this tutorial will modify some files under version control in the
F Prime git repository.
Therefore it is a good idea to do this work on a new branch.
For example:

[source,bash]
----
% git checkout release/v3.0.0
% git checkout -b math-tutorial
----

If you wish, you can save your work by committing to this branch.

== The MathOp Type

In F Prime, a *type definition* defines a kind of data that you can pass
between components or use in commands and telemetry.

For this tutorial, we need one type definition.
It defines an enumeration called `MathOp`, which
represents a mathematical operation.

We will add the specification for the `MathOp` type to the
`Ref` topology.
We will do this in three stages:

. Construct the FPP model.
. Add the model to the project.
. Build the model.

=== Construct the FPP Model

*In directory Ref:*
Go to the directory `Ref` at the top-level of the
F Prime repository and run `mkdir MathTypes`.
This step creates a new directory `Ref/MathTypes`.
This directory will contain our new type.

*In directory Ref/MathTypes:*
Now go into the directory `Ref/MathTypes`.
Create a file `MathTypes.fpp` with the following contents:

[source,fpp]
----
module Ref {

  @ A math operation
  enum MathOp {
    ADD @< Addition
    SUB @< Subtraction
    MUL @< Mutliplication
    DIV @< Division
  }

}
----

You can do this by typing, or by copy-paste.

This file defines an enumeration or *enum*
with enumerated constants `ADD`, `SUB`, `MUL`, and `DIV`.
These four constants represent the operations
of addition, subtraction, multiplication, and division.
The enum also defines a type `MathOp`; the enumerated
constants are the values of this type.
For more information on enums, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Enums[_The FPP User's Guide_].

The enum `MathTypes` resides in an FPP module `Ref`.
An FPP module is like a {cpp} namespace: it encloses
several definitions, each of which is qualified with the
name of the module.
For more information on FPP modules, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Modules[_The FPP User's Guide_].

The text following a symbol `@` or `@<` is called an
*annotation*.
These annotations are carried through the parsing and
become comments in the generated code.
For more information, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Writing-Comments-and-Annotations[_The FPP User's Guide_].


[[types-add]]
=== Add the Model to the Project

*In directory Ref/MathTypes:*
Create a file `Ref/MathTypes/CMakeLists.txt` with the following contents:

[source,cmake]
----
set(SOURCE_FILES
  "${CMAKE_CURRENT_LIST_DIR}/MathTypes.fpp"
)

register_fprime_module()
----

This code will tell the build system how to build the FPP model.

*In directory Ref:*
Now we need to add the new directory to the `Ref` project.
To do that, open the file `Ref/CMakeLists.txt`.
This file should already exist; it was put there by the developers
of the `Ref` topology.
In this file, you should see several lines starting with `add_fprime_subdirectory`.
Immediately after the last of those lines, add the following new line:

[source,cmake]
----
add_fprime_subdirectory("${CMAKE_CURRENT_LIST_DIR}/MathTypes/")
----

[[types-build]]
=== Build the Model

*In directory Ref/MathTypes:*
Do the following:

. Go to the directory `Ref/MathTypes`.
. If you have not already run `fprime-util generate`, then do so now.
. Run the command `fprime-util build`.

The output should indicate that the model built without any errors.
If not, try to identify and correct what is wrong,
either by deciphering the error output, or by going over the steps again.

*In directory Ref/build-fprime-automatic-native/Ref/MathTypes:*
Now go to the directory `Ref/build-fprime-automatic-native/Ref/MathTypes`
(you may want to use `pushd`, or do this in a separate shell).
The directory `build-fprime-automatic-native` is where all the
generated code lives for the "automatic native" build of the `Ref`
project.
Within that directory is a directory tree that mirrors the project
structure.
In particular, `Ref/build-fprime-automatic-native/Ref/MathTypes`
contains the generated code for `Ref/MathTypes`.

Run `ls`.
You should see something like this:

[source,bash]
----
CMakeFiles            MathOpEnumAc.cpp      MathOpEnumAi.xml.prev cmake_install.cmake
Makefile              MathOpEnumAc.hpp      autocoder
----

The files `MathOpEnumAc.hpp` and
`MathOpEnumAc.cpp` are the auto-generated {cpp} files
corresponding to the `MathOp` enum.
You may wish to study the file `MathOpEnumAc.hpp`.
This file gives the interface to the {cpp} class `Ref::MathOp`.
All enum types have a similar auto-generated class
interface.

[[ports]]
== The MathOp and MathResult Ports

A *port* is the endpoint of a connection between
two components.
A *port definition* is like a function signature;
it defines the type of the data carried on a port.

For this tutorial, we need two port definitions:

* `MathOp` for sending an arithmetic operation request from 
`MathSender` to `MathReceiver`.

* `MathResult` for sending the result of an arithmetic
operation from `MathReceiver` to `MathSender`.

We follow the same three steps as in the previous section.

=== Construct the FPP Model

*In directory Ref:*
Go to the directory `Ref` at the top-level of the
F Prime repository and run `mkdir MathPorts`.
This directory will contain our new ports.

*In directory Ref/MathPorts:*
Now go into the directory `Ref/MathPorts`.
Create a file `MathPorts.fpp` with the following contents:

[source,fpp]
----
module Ref {

  @ Port for requesting an operation on two numbers
  port MathOp(
               val1: F32 @< The first operand
               op: MathOp @< The operation
               val2: F32 @< The second operand
             )

  @ Port for returning the result of a math operation
  port MathResult(
                   result: F32 @< the result of the operation
                 )

}
----

This file defines the ports `MathOp` and `MathResult`.
`MathOp` has three formal parameters: a first operand, an
operation, and a second operand.
The operands have type `F32`, which represents a 32-bit
floating-point number.
The operation has type `MathOp`, which is the enum type
we defined in the previous section.
`MathResult` has a single formal parameter, the value of type `F32`
returned as the result of the operation.

For more information about port definitions, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Ports[_The FPP User's Guide_].

=== Add the Model to the Project

Add add the model
`Ref/MathPorts/MathPorts.fpp` to the `Ref` project.
Carry out the steps in the
<<types-add,previous section>>, after
substituting `MathPorts` for `MathTypes`.

=== Build the Model

Carry out the steps in the
<<types-build,previous section>>,
in directory `MathPorts` instead of `MathTypes`.
The generated code will go in
`Ref/build-fprime-automatic-native/Ref/MathPorts`.
For port definitions, the names of the auto-generated {cpp}
files end in `PortAc.hpp` and `PortAc.cpp`.
You can look at this code if you wish.
However, the auto-generated {cpp} port files are used
by the autocoded component implementations (described below);
you won't ever program directly against their interfaces.

== The MathSender Component

Now we can build and test the `MathSender` component.
There are five steps:

. Construct the FPP model.
. Add the model to the project.
. Build the stub implementation.
. Complete the implementation.
. Write and run unit tests.

=== Construct the FPP Model

*In directory Ref:*
Go to the directory `Ref` at the top-level of the
F Prime repository.
Run `mkdir MathSender` to create a directory for the new component.

*In directory Ref/MathSender:*
Now go into the directory `Ref/MathSender`.
Create a file `MathSender.fpp` with the following contents:

[source,fpp]
----
module Ref {

  @ Component for sending a math operation
  active component MathSender {

    # ----------------------------------------------------------------------
    # General ports 
    # ----------------------------------------------------------------------

    @ Port for sending the operation request
    output port mathOpOut: MathOp

    @ Port for receiving the result
    async input port mathResultIn: MathResult

    # ----------------------------------------------------------------------
    # Special ports 
    # ----------------------------------------------------------------------

    @ Command receive port
    command recv port cmdIn

    @ Command registration port
    command reg port cmdRegOut

    @ Command response port
    command resp port cmdResponseOut

    @ Event port
    event port eventOut

    @ Telemetry port
    telemetry port tlmOut

    @ Text event port
    text event port textEventOut

    @ Time get port
    time get port timeGetOut

    # ----------------------------------------------------------------------
    # Commands 
    # ----------------------------------------------------------------------

    @ Do a math operation
    async command DO_MATH(
                           val1: F32 @< The first operand
                           op: MathOp @< The operation
                           val2: F32 @< The second operand
                         )

    # ----------------------------------------------------------------------
    # Events 
    # ----------------------------------------------------------------------

    @ Math command received
    event COMMAND_RECV(
                        val1: F32 @< The first operand
                        op: MathOp @< The operation
                        val2: F32 @< The second operand
                      ) \
      severity activity low \
      format "Math command received: {f} {} {f}"

    @ Received math result
    event RESULT(
                  result: F32 @< The math result
                ) \
      severity activity high \
      format "Math result is {f}"

    # ----------------------------------------------------------------------
    # Telemetry 
    # ----------------------------------------------------------------------

    @ The first value
    telemetry VAL1: F32

    @ The operation
    telemetry OP: MathOp

    @ The second value
    telemetry VAL2: F32

    @ The result
    telemetry RESULT: F32

  }

}
----

This code defines a component `Ref.MathSender`.
The component is *active*, which means it has its
own thread.

Inside the definition of the `MathSender` component are
several specifiers.
We have divided the specifiers into five groups:

. *General ports:* These are user-defined ports for
application-specific functions.
There are two general ports: an output port `mathOpOut`
of type `MathOp` and an input port `mathResultIn` of
type `MathResult`.
Notice that these port specifiers use the ports that
we defined <<ports,above>>.
The input port is *asynchronous*.
This means that when the port is invoked (i.e., when
data is sent on the port) a message is placed on a queue,
and its handler is later run on the thread of this component.

. *Special ports:* These are ports that have a special
meaning in F Prime.
There are ports for registering commands with the dispatcher,
receiving commands, sending command responses, emitting
event reports, emitting telemetry, and getting the time.

. *Commands:* These are commands sent from the ground
or from a sequencer and dispatched to this component.
There is one command `DO_MATH` for doing a math operation.
The command is asynchronous.
This means that when the command arrives, it goes on a queue
and its handler is later run on the thread of this component.

. *Events:* These are event reports that this component
can emit.
There are two event reports, one for receiving a command
and one for receiving a result.

. *Telemetry:* These are *channels* that define telemetry
points that the this component can emit.
There are four telemetry channels: three for the arguments
to the last command received and one for the last
result received.

For more information on defining components, see
https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components[_The FPP User's Guide_].

=== Add the Model to the Project

*In directory Ref/MathSender:*
Create a file `Ref/MathSender/CMakeLists.txt` with the following contents:

[source,cmake]
----
# Register the standard build
set(SOURCE_FILES
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.cpp"
  "${CMAKE_CURRENT_LIST_DIR}/MathSender.fpp"
)
register_fprime_module()
----

This code will tell the build system how to build the FPP model
and component implementation.

*In directory Ref:*
Add `Ref/MathTypes` to `Ref/CMakeLists.txt`, as we did
for the <<types-add,`MathOp` type>>.

=== Build the Stub Implementation

*In directory Ref/MathTypes:*
Go into the directory `Ref/MathTypes`.
Run the command `fprime-util impl`.
The build system should
run for a bit. At the end there should be two new files
in the directory: 
`MathSenderComponentImpl.cpp-template` and
`MathSenderComponentImpl.hpp-template`.
Run the following commands:

[source,bash]
----
mv MathSenderComponentImpl.cpp-template MathSender.cpp
mv MathSenderComponentImpl.hpp-template MathSender.hpp
----

These commands produce a template, or stub implementation,
of the `MathSender` implementation class.
You will fill in this implementation class below.

Now run the command `fprime-util build`.
The model and the stub implementation should build.

*In directory Ref/build-fprime-automatic-native/Ref/MathSender:*
The generated code resides in this directory.
You may wish to look over the file `MathSenderComponentAc.hpp`
to get an idea of the interface to the auto-generated
base class `MathSenderComponentBase`.
The `MathSender` implementation class is a derived class
of this base class.

=== Complete the Implementation

Now we can complete the stub implementation.
In an editor, open the file `MathSender.cpp`.

*Fill in the DO_MATH command handler:*
You should see a stub handler for the `DO_MATH`
command that looks like this:

[source,c++]
----
void MathSender ::
  DO_MATH_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq,
      F32 val1,
      MathOp op,
      F32 val2
  )
{
  // TODO
  this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::OK);
}
----

The handler `DO_MATH_handler` is called when the `MathSender`
component receives a `DO_MATH` command.
This handler overrides the corresponding pure virtual
function in the auto-generated base class.
Fill in the handler so that it looks like this:

[source,c++]
----
void MathSender ::
  DO_MATH_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq,
      F32 val1,
      MathOp op,
      F32 val2
  )
{
  this->tlmWrite_VAL1(val1);
  this->tlmWrite_OP(op);
  this->tlmWrite_VAL2(val2);
  this->log_ACTIVITY_LO_COMMAND_RECV(val1, op, val2);
  this->mathOpOut_out(0, val1, op, val2);
  this->cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);
}
----

The first two arguments to the handler function provide
the command opcode and the command sequence number
(a unique identifier generated by the command dispatcher).
The remaining arguments are supplied when the command is sent,
for example, from the F Prime ground data system (GDS).
The implementation code does the following:

. Emit telemetry and events.
. Invoke the `mathOpOut` port to request that `MathReceiver`
perform the operation.
. Send a command response indicating success.
The command response goes out on the special port
`cmdResponseOut`.

*Check the build:*
Run `fprime-util build` again to make sure that everything still builds.

*Fill in the mathResultIn handler:*
You should see a stub handler for the `mathResultIn`
port that looks like this:

[source,c++]
----
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
  // TODO
}
----

The handler `mathResultIn_handler` is called when the `MathReceiver`
component code returns a result by invoking the `mathResultIn` port.
Again the handler overrides the corresponding pure virtual
function in the auto-generated base class.
Fill in the handler so that it looks like this:

[source,c++]
----
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
    this->tlmWrite_RESULT(result);
    this->log_ACTIVITY_HI_RESULT(result);
}
----

The implementation code emits the result on the `RESULT`
telemetry channel and as a `RESULT` event report.

*Check the build:*
Run `fprime-util build`.

=== Write and Run Unit Tests

*Unit tests* are an important part of FSW development.
At the component level, unit tests at the component level exercise a component's
functions by invoking input ports, sending commands, and
checking for expected values on output ports (including telemetry and event
ports).

TODO

== The MathReceiver Component

TODO

=== Construct the FPP Model

TODO

=== Add the Model to the Project

TODO

=== Build the Model

TODO

=== Complete the Implementation

TODO

=== Write and Run Unit Tests

TODO

== Updating the Ref Topology

TODO

== Running the Ref Deployment

TODO
