##
## Template to stamp out serializable arrays .hpp file
##
// ====================================================================== 
// \title  ${name}.hpp
// \author Auto-generated
// \brief  hpp file for ${name}
//
// \copyright
// Copyright (C) 2020 California Institute of Technology.
// ALL RIGHTS RESERVED.  United States Government Sponsorship
// acknowledged. Any commercial use must be negotiated with the Office
// of Technology Transfer at the California Institute of Technology.
// 
// This software may be subject to U.S. export control laws and
// regulations.  By accepting this document, the user agrees to comply
// with all U.S. export laws and regulations.  User has the
// responsibility to obtain export licenses, or other export authority
// as may be required before exporting such information to foreign
// countries or providing access to foreign persons.
// ======================================================================

\#ifndef ${namespace}_${name}_HPP
\#define ${namespace}_${name}_HPP

\#include "Fw/Types/BasicTypes.hpp"
\#include "Fw/Types/Serializable.hpp"
// To add include directives here, put them in a file called Include/${name}EnumAc.hpp

namespace ${namespace} {
  class ${name} : public Fw::Serializable
  {
    public:
    // ----------------------------------------------------------------------
    // Helper Types
    // ----------------------------------------------------------------------

    typedef ${type} ElementType;
    
    enum {
        SIZE=${size},
#if $type == "string":
        SERIALIZED_SIZE = SIZE * sizeof(${string_type})
#else:
        SERIALIZED_SIZE = SIZE * sizeof(${type})
#end if
        };
  
    public:
  
    // ----------------------------------------------------------------------
    // Constructors
    // ----------------------------------------------------------------------
  
      //! Construct a ${name} with default initialization
      ${name}(void);
  
      //! Construct a ${name} and initialize its elements from an array
      ${name}(
          const ElementType (&a)[SIZE] //!< The array
      );
  
      //! Construct a ${name} and initialize its elements from a single element
      ${name}(
          const ElementType& e //!< The element
      );
  
      //! Construct a ${name} and initialize its elements from elements
   ${name}(
#for $i in $range(1, $size + 1):
#if $i != $size:
      const ElementType (&e${i}), //!< Element ${i}
#else:
      const ElementType (&e${i})
#end if
#end for
      );
  
      //! Copy constructor
      ${name}(
          const ${name}& other //!< The other object
      );
  
    public:
  
      // ----------------------------------------------------------------------
      // Public operators
      // ----------------------------------------------------------------------
  
      //! Subscript operator
      ElementType& operator[](
          const U32 i //!< The subscript index
      );
  
      //! Const subscript operator
      const ElementType& operator[](
          const U32 i //!< The subscript index
      ) const;
  
      //! Assignment operator
      const ${name}& operator=(
          const ${name}& other //!< The other object
      );
  
      //! Assignment operator from array
      const ${name}& operator=(
          const ElementType (&a)[SIZE] //!< The array
      );
  
      //! Assignment operator from element
      const ${name}& operator=(
          const ElementType& e //!< The element
      );
  
      //! Equality operator
      bool operator==(
          const ${name}& other //!< The other object
      ) const;
  
      //! Inequality operator
      bool operator!=(
          const ${name}& other //!< The other object
      ) const;
  
\#ifdef BUILD_UT
      //! Ostream operator
      friend std::ostream& operator<<(
          std::ostream& os, //!< The ostream
          const ${name}& obj //!< The object
      );
\#endif
  
    public:
  
    // ----------------------------------------------------------------------
    // Public methods
    // ----------------------------------------------------------------------
  
    //! Serialization
    Fw::SerializeStatus serialize(
        Fw::SerializeBufferBase& buffer //!< The serial buffer
    ) const;
  
    //! Deserialization
    Fw::SerializeStatus deserialize(
        Fw::SerializeBufferBase& buffer //!< The serial buffer
    );

\#if FW_ARRAY_TO_STRING || BUILD_UT
    void toString(Fw::StringBase& text) const; //!< generate text from serializable
\#endif

    protected:

    enum {
        TYPE_ID = ${uuid} //!< type id
    };
  
    private:
  
    // ----------------------------------------------------------------------
    // Private member variables
    // ----------------------------------------------------------------------
  
    //! The array elements
    ElementType elements[SIZE];
  
  };

}

#endif